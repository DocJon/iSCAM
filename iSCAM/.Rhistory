bionomic(theta)
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/Tutorials2010/Bionomic.R",echo=TRUE)
bionomic(theta)
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/Tutorials2010/Bionomic.R",echo=TRUE)
bionomic(theta)
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/Tutorials2010/Bionomic.R",echo=TRUE)
qo
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/Tutorials2010/Bionomic.R",echo=TRUE)
qo
bionomic(theta)
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/Tutorials2010/Bionomic.R",echo=TRUE)
bionomic(theta)
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/Tutorials2010/Bionomic.R",echo=TRUE)
bionomic(theta)
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/Tutorials2010/Bionomic.R",echo=TRUE)
bionomic(theta)
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/Tutorials2010/Bionomic.R",echo=TRUE)
bionomic(theta)
warnings()
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/Tutorials2010/Bionomic.R",echo=TRUE)
warnings()
bionomic(theta)
warnings()
bionomic(theta)
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/Tutorials2010/Bionomic.R",echo=TRUE)
bionomic(theta)
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/Tutorials2010/Bionomic.R",echo=TRUE)
bionomic(theta)
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/Tutorials2010/Bionomic.R",echo=TRUE)
bionomic(theta)
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/Tutorials2010/Bionomic.R",echo=TRUE)
bionomic(theta)
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/Tutorials2010/Bionomic.R",echo=TRUE)
bionomic(theta)
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/Tutorials2010/Bionomic.R",echo=TRUE)
bionomic(theta)
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/Tutorials2010/Bionomic.R",echo=TRUE)
bionomic(theta)
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/Tutorials2010/Bionomic.R",echo=TRUE)
bionomic(theta)
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/Tutorials2010/Bionomic.R",echo=TRUE)
bionomic(theta)
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/Tutorials2010/Bionomic.R",echo=TRUE)
bionomic(theta)
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/Tutorials2010/Bionomic.R",echo=TRUE)
qo
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/Tutorials2010/Bionomic.R",echo=TRUE)
reck
no
qo
price
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/Tutorials2010/Bionomic.R",echo=TRUE)
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/Tutorials2010/LRGS.R",echo=TRUE)
hake
??get
?file.choose
x=read.table(file.choose())
hake
head(hake)
tail(hake)
hake$Year
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/Tutorials2010/LRGS.R",echo=TRUE)
ct
yt
head(hake)
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/Tutorials2010/LRGS.R",echo=TRUE)
yt
yr
ct
hake$CPUE
hake
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/Tutorials2010/LRGS.R",echo=TRUE)
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/Tutorials2010/EDOMwcvi.R",echo=TRUE)
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/Tutorials2010/EDOM_Map.r",echo=TRUE)
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/Tutorials2010/EDOMwcvi.R",echo=TRUE)
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/Tutorials2010/EDOMdemo.R",echo=TRUE)
exp
exp()
exp(1)
(1+10000/10)^10
(1+1/10)^10
n=1000
(1+1/n)^n
n=1e10
(1+1/n)^n
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/Tutorials2010/ForagingArena.R",echo=TRUE)
?text
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/Tutorials2010/ForagingArena.R",echo=TRUE)
R
plot(nt,R)
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/Tutorials2010/ForagingArena.R",echo=TRUE)
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/Tutorials2010/EDOMdemo.R",echo=TRUE)
a
b
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/Tutorials2010/EDOMdemo.R",echo=TRUE)
ni
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/Tutorials2010/EDOMdemo.R",echo=TRUE)
head(li)
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/Tutorials2010/EDOMdemo.R",echo=TRUE)
x
li
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/Tutorials2010/EDOMdemo.R",echo=TRUE)
fi
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/Tutorials2010/EDOMdemo.R",echo=TRUE)
ni
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/Tutorials2010/EDOMdemo.R",echo=TRUE)
ni
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/Tutorials2010/EDOMdemo.R",echo=TRUE)
ni
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/Tutorials2010/EDOMdemo.R",echo=TRUE)
ni
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/Tutorials2010/EDOMdemo.R",echo=TRUE)
require(Riscam)
read.admb
?read.admb
library(Riscam)
?read.admb
rm(Riscam)
require(Riscam)
read.admb
?read.rep
source("/Users/stevenmartell/Documents/UBC Courses/Fish 504/DataSets/StateSpaceSockeye.R",echo=TRUE)
dir()
examples(trellis)
example(lattice)
??lattice
RSiteSearch("MCMC trace plots")
data(NOdata)#
attach(NOdata)#
beta<-matrix(c(1.3, -0.1, 0.6, 0.1), 2, 2)#
sigma<-c(.02, .05)#
MH.out<-regmixMH(Equivalence, NO, beta = beta, s = sigma, #
                 sampsize = 2500, omega = .0013)#
plot(MH.out, summary.plots = TRUE, burnin = 2450, #
     alpha = 0.01)
qq(voice.part ~ height, aspect = 1, data = singer,#
   subset = (voice.part == "Bass 2" | voice.part == "Tenor 1"))
require(lattice)
qq(voice.part ~ height, aspect = 1, data = singer,#
   subset = (voice.part == "Bass 2" | voice.part == "Tenor 1"))
## volcano  ## 87 x 61 matrix#
wireframe(volcano, shade = TRUE,#
          aspect = c(61/87, 0.4),#
          light.source = c(10,0,10))
g <- expand.grid(x = 1:10, y = 5:15, gr = 1:2)#
g$z <- log((g$x^g$g + g$y^2) * g$gr)#
wireframe(z ~ x * y, data = g, groups = gr,#
          scales = list(arrows = FALSE),#
          drape = TRUE, colorkey = TRUE,#
          screen = list(z = 30, x = -60))
cloud(Sepal.Length ~ Petal.Length * Petal.Width | Species, data = iris,#
      screen = list(x = -90, y = 70), distance = .4, zoom = .6)
example(xyplot)
barley
A
x=rnorm(10000)
xplot(x)
xyplot(x)
x=1:10000
y=rnorm(length(x))
xplot(x,y)
xyplot(x,y)
?xyplot
xyplot(y~x)
xyplot(y~x,type="l")
qqmath(y)
xyplot(y~x,type="l")
y2=rnorm(length(x))
dd=cbind(x,y,y2)
xyplot(x,data=dd)
xyplot(~x,data=dd)
xyplot(dd[-1]~x,data=dd)
xyplot(dd[,-1]~x,data=dd)
xplot(y2)
demo(lattice)
singer
densityplot( ~ height | voice.part, data = singer, layout = c(2, 4),  #
+             xlab = "Height (inches)",#
+             ylab = "Kernel Density\n with Normal Fit",#
+             main = list("Estimated Density", cex = 1.4, col = "DarkOliveGreen"),#
+             panel = function(x, ...) {#
+                 panel.densityplot(x, ...)#
+                 panel.mathdensity(dmath = dnorm,#
+                                   args = list(mean=mean(x),sd=sd(x)))#
+             } )
x
densityplot(x)
densityplot(dd)
densityplot(~dd)
densityplot(~dd|x)
head(dd)
densityplot(~y|x)
?densityplot
densityplot(dd[,-1])
dd[-1]
dd[,-1]
example(densityplot)
head(singer)
is.data.frame(singer)
densityplot(dd~)
densityplot(dd~,data=dd)
densityplot(dd,data=dd)
densityplot(x~,data=dd)
densityplot(~x,data=dd)
is.data.frame(dd)
dd=as.data.frame(dd)
densityplot(~x,data=dd)
densityplot(~y,data=dd)
densityplot(~y2,data=dd)
densityplot(~x|y,data=dd)
densityplot(|y,data=dd)
densityplot(|x,data=dd)
densityplot(y,data=dd)
setwd('/Users/stevenmartell/Documents/REVIEWS/POP Assessment')
#POPReview.R#
#
#Equilibrium sex structured model to explore reference points#
#for the POP assessment.#
#
#s = index for sex 1=females,  2=males#
A=60  #age of plus group.#
age=1:A#
s=1:2#
show=T#
discrete=T#
#PARAMETERS#
ro		<- 20507#
h		<- 0.754#
kap		<- 4*h/(1-h)#
m		<- c(0.067, 0.073)#
mu		<- 12.4#
delta	<- 0.39#
log.vl	<- 3.52#
linf	<- c(45.11, 41.62)#
k		<- c(0.1404, 0.1675)#
to		<- c(-1.3035, -1.0210)#
a		<- c(9.26e-6, 8.13e-6)#
b		<- c(3.116, 3.155)#
ma		<- c(0, 0, 0, 0, 0.023, #
			0.034, 0.096, 0.211, 0.341, 0.465, #
			0.601, 0.738, 0.860, 0.950, 0.996, #
			rep(1.000,length=45))#
#
theta=list(ro=ro, h=h, m=m, mu=mu, delta=delta, log.vl=log.vl, #
			linf=linf, k=k, to=to, a=a, b=b, ma=ma)#
#
#PROCEDURES#
par(mfcol=c(2, 2))#
equil.age <- function(theta, fe=0)#
{#
	#Double logistic selectivity#
	sa = exp(-(age-mu)^2/exp(log.vl))  #female#
	sa = cbind(sa,exp(-(age-mu+delta)^2/exp(log.vl)) )  #male baseed on delta offset#
	sa[age>mu, 1]=1#
	sa[age>(mu+delta), 2]=1#
	#
	#
	#Growth#
	la=sapply(s, function(s)linf[s]*(1-exp(-k[s]*(age-to[s]))))#
	wa=sapply(s, function(s)a[s]*la[,s]^b[s])#
	fa=ma*wa[,1]#
	#
	#
	#Incidence functions#
	lx = sapply(s, function(s) exp(-m[s])^(age-1))#
	lx[A,]=lx[A,]/(1-exp(-m))	#plus group#
	phie = sum(0.5*lx[,1]*fa)		#female eggs per recruit#
	#
	#
	#Stock recruitment parameters for beverton-holt model#
	so=kap/phie#
	beta=(kap-1)/(ro*phie)#
	#
	lz = matrix(0, nrow=A, ncol=2)#
	#Fished conditions (instantaneous rates)#
	#fe=0.0#
	za = t(m + fe*t(sa))#
	oa = 1-exp(-za)#
	qa = (sa/za)*oa#
	#
	lz[1, ] = 1.0#
	for(i in 2:A)#
	{#
		lz[i,] = lz[i-1, ]*exp(-za[i-1, ])#
		if(i==A) lz[i,]=lz[i, ]/(1-exp(-za[i, ]))#
	}#
	#
	#Fished conditions (discrete rates)#
	if(discrete){#
		lz[i, ] = 1.0#
		oa = (1-t(fe*t(sa)))#
		qa=sa#
		for(i in 2:A)#
		{#
			lz[i, ]=(lz[i-1, ]*exp(-m/2)*oa[i,])*exp(-m/2)#
			if(i==A) lz[i,]=lz[i, ]/(1-(exp(-m/2)*oa[i,])*exp(-m/2))#
		}#
	}#
	#
	phif = sum(0.5*lz[, 1]*fa)		#fished female eggs per recruit#
	phiq = sum(0.5*lz*wa*qa)#
	print(phiq)#
	#
	re = max(ro*(kap-phie/phif)/(kap-1), 0)#
	be = re*phif#
	ye = fe*re*phiq#
	spr = phif/phie#
	#
	#
	#
	#
	#Graphics#
	if(show)#
	{#
		matplot(age, sa, type="l", xlim=c(0, 20),xlab="Age", ylab="Selectivity")#
		matplot(age, la, type="o")#
		matplot(age, wa, type="o")#
		matlines(age, fa, type="l", col=3)#
		matplot(age, lx, type="l",xlab="Age", ylab="Survivorship")#
		matlines(age, lz, col=3:4)#
	}#
	#
	return(list(ye=ye, re=re, be=be, spr=spr))#
}#
show=TRUE#
equil.age(theta, 0)#
show=FALSE#
fe=seq(0,0.5,by=0.001)#
ee=as.data.frame(t(sapply(fe,equil.age,theta=theta)))#
ye=unlist(ee[,1])#
re=unlist(ee[,2])#
be=unlist(ee[,3])#
spr=unlist(ee[,4])#
#
imsy= which(ye==max(ye))#
#
plot(fe,ye, type="l",xlab="Umsy", ylab="Yield")#
text(median(fe),ye[imsy],paste("Umsy =", fe[imsy],"\nMSY =", round(ye[imsy], 0)), pos=1)#
plot(fe,re, type="l")#
text(median(fe),ro, paste("Ro =",ro), pos=1)#
plot(fe,be, type="l")#
text(fe[imsy],be[imsy], paste("Bmsy =",round(be[imsy], 0)), pos=1)#
plot(fe,spr, type="l")#
#
#
print(paste("Fmsy =", fe[imsy]))#
print(paste("MSY =", round(ye[imsy], 0)))#
print(paste("Rmsy =", round(re[imsy], 0)))#
print(paste("Bmsy =", round(be[imsy], 0)))#
print(paste("SPRmsy =", round(spr[imsy], 3)))
setwd('/Users/stevenmartell/Documents/REVIEWS/POP Assessment')
#POPReview.R#
#
#Equilibrium sex structured model to explore reference points#
#for the POP assessment.#
#
#s = index for sex 1=females,  2=males#
A=60  #age of plus group.#
age=1:A#
s=1:2#
show=T#
discrete=T#
#PARAMETERS#
ro		<- 20507#
h		<- 0.754#
kap		<- 4*h/(1-h)#
m		<- c(0.067, 0.073)#
mu		<- 12.4#
delta	<- 0.39#
log.vl	<- 3.52#
linf	<- c(45.11, 41.62)#
k		<- c(0.1404, 0.1675)#
to		<- c(-1.3035, -1.0210)#
a		<- c(9.26e-6, 8.13e-6)#
b		<- c(3.116, 3.155)#
ma		<- c(0, 0, 0, 0, 0.023, #
			0.034, 0.096, 0.211, 0.341, 0.465, #
			0.601, 0.738, 0.860, 0.950, 0.996, #
			rep(1.000,length=45))#
#
theta=list(ro=ro, h=h, m=m, mu=mu, delta=delta, log.vl=log.vl, #
			linf=linf, k=k, to=to, a=a, b=b, ma=ma)#
#
#PROCEDURES#
par(mfcol=c(2, 2))#
equil.age <- function(theta, fe=0)#
{#
	#Double logistic selectivity#
	sa = exp(-(age-mu)^2/exp(log.vl))  #female#
	sa = cbind(sa,exp(-(age-mu+delta)^2/exp(log.vl)) )  #male baseed on delta offset#
	sa[age>mu, 1]=1#
	sa[age>(mu+delta), 2]=1#
	#
	#
	#Growth#
	la=sapply(s, function(s)linf[s]*(1-exp(-k[s]*(age-to[s]))))#
	wa=sapply(s, function(s)a[s]*la[,s]^b[s])#
	fa=ma*wa[,1]#
	#
	#
	#Incidence functions#
	lx = sapply(s, function(s) exp(-m[s])^(age-1))#
	lx[A,]=lx[A,]/(1-exp(-m))	#plus group#
	phie = sum(0.5*lx[,1]*fa)		#female eggs per recruit#
	#
	#
	#Stock recruitment parameters for beverton-holt model#
	so=kap/phie#
	beta=(kap-1)/(ro*phie)#
	#
	lz = matrix(0, nrow=A, ncol=2)#
	#Fished conditions (instantaneous rates)#
	#fe=0.0#
	za = t(m + fe*t(sa))#
	oa = 1-exp(-za)#
	qa = (sa/za)*oa#
	#
	lz[1, ] = 1.0#
	for(i in 2:A)#
	{#
		lz[i,] = lz[i-1, ]*exp(-za[i-1, ])#
		if(i==A) lz[i,]=lz[i, ]/(1-exp(-za[i, ]))#
	}#
	#
	#Fished conditions (discrete rates)#
	if(discrete){#
		lz[i, ] = 1.0#
		oa = (1-t(fe*t(sa)))#
		qa=sa#
		for(i in 2:A)#
		{#
			lz[i, ]=(lz[i-1, ]*exp(-m/2)*oa[i,])*exp(-m/2)#
			if(i==A) lz[i,]=lz[i, ]/(1-(exp(-m/2)*oa[i,])*exp(-m/2))#
		}#
	}#
	#
	phif = sum(0.5*lz[, 1]*fa)		#fished female eggs per recruit#
	phiq = sum(0.5*lz*wa*qa)#
	print(phiq)#
	#
	re = max(ro*(kap-phie/phif)/(kap-1), 0)#
	be = re*phif#
	ye = fe*re*phiq#
	spr = phif/phie#
	#
	#
	#
	#
	#Graphics#
	if(show)#
	{#
		matplot(age, sa, type="l", xlim=c(0, 20),xlab="Age", ylab="Selectivity")#
		matplot(age, la, type="o")#
		matplot(age, wa, type="o")#
		matlines(age, fa, type="l", col=3)#
		matplot(age, lx, type="l",xlab="Age", ylab="Survivorship")#
		matlines(age, lz, col=3:4)#
	}#
	#
	return(list(ye=ye, re=re, be=be, spr=spr))#
}#
show=TRUE#
equil.age(theta, 0)#
show=FALSE#
fe=seq(0,0.5,by=0.001)#
ee=as.data.frame(t(sapply(fe,equil.age,theta=theta)))#
ye=unlist(ee[,1])#
re=unlist(ee[,2])#
be=unlist(ee[,3])#
spr=unlist(ee[,4])#
#
imsy= which(ye==max(ye))#
#
plot(fe,ye, type="l",xlab="Umsy", ylab="Yield")#
text(median(fe),ye[imsy],paste("Umsy =", fe[imsy],"\nMSY =", round(ye[imsy], 0)), pos=1)#
plot(fe,re, type="l")#
text(median(fe),ro, paste("Ro =",ro), pos=4)#
plot(fe,be, type="l")#
text(fe[imsy],be[imsy], paste("Bmsy =",round(be[imsy], 0)), pos=1)#
plot(fe,spr, type="l")#
#
#
print(paste("Fmsy =", fe[imsy]))#
print(paste("MSY =", round(ye[imsy], 0)))#
print(paste("Rmsy =", round(re[imsy], 0)))#
print(paste("Bmsy =", round(be[imsy], 0)))#
print(paste("SPRmsy =", round(spr[imsy], 3)))
setwd('/Users/stevenmartell/Documents/REVIEWS/POP Assessment')
#POPReview.R#
#
#Equilibrium sex structured model to explore reference points#
#for the POP assessment.#
#
#s = index for sex 1=females,  2=males#
A=60  #age of plus group.#
age=1:A#
s=1:2#
show=T#
discrete=T#
#PARAMETERS#
ro		<- 20507#
h		<- 0.754#
kap		<- 4*h/(1-h)#
m		<- c(0.067, 0.073)#
mu		<- 12.4#
delta	<- 0.39#
log.vl	<- 3.52#
linf	<- c(45.11, 41.62)#
k		<- c(0.1404, 0.1675)#
to		<- c(-1.3035, -1.0210)#
a		<- c(9.26e-6, 8.13e-6)#
b		<- c(3.116, 3.155)#
ma		<- c(0, 0, 0, 0, 0.023, #
			0.034, 0.096, 0.211, 0.341, 0.465, #
			0.601, 0.738, 0.860, 0.950, 0.996, #
			rep(1.000,length=45))#
#
theta=list(ro=ro, h=h, m=m, mu=mu, delta=delta, log.vl=log.vl, #
			linf=linf, k=k, to=to, a=a, b=b, ma=ma)#
#
#PROCEDURES#
par(mfcol=c(2, 2))#
equil.age <- function(theta, fe=0)#
{#
	#Double logistic selectivity#
	sa = exp(-(age-mu)^2/exp(log.vl))  #female#
	sa = cbind(sa,exp(-(age-mu+delta)^2/exp(log.vl)) )  #male baseed on delta offset#
	sa[age>mu, 1]=1#
	sa[age>(mu+delta), 2]=1#
	#
	#
	#Growth#
	la=sapply(s, function(s)linf[s]*(1-exp(-k[s]*(age-to[s]))))#
	wa=sapply(s, function(s)a[s]*la[,s]^b[s])#
	fa=ma*wa[,1]#
	#
	#
	#Incidence functions#
	lx = sapply(s, function(s) exp(-m[s])^(age-1))#
	lx[A,]=lx[A,]/(1-exp(-m))	#plus group#
	phie = sum(0.5*lx[,1]*fa)		#female eggs per recruit#
	#
	#
	#Stock recruitment parameters for beverton-holt model#
	so=kap/phie#
	beta=(kap-1)/(ro*phie)#
	#
	lz = matrix(0, nrow=A, ncol=2)#
	#Fished conditions (instantaneous rates)#
	#fe=0.0#
	za = t(m + fe*t(sa))#
	oa = 1-exp(-za)#
	qa = (sa/za)*oa#
	#
	lz[1, ] = 1.0#
	for(i in 2:A)#
	{#
		lz[i,] = lz[i-1, ]*exp(-za[i-1, ])#
		if(i==A) lz[i,]=lz[i, ]/(1-exp(-za[i, ]))#
	}#
	#
	#Fished conditions (discrete rates)#
	if(discrete){#
		lz[i, ] = 1.0#
		oa = (1-t(fe*t(sa)))#
		qa=sa#
		for(i in 2:A)#
		{#
			lz[i, ]=(lz[i-1, ]*exp(-m/2)*oa[i,])*exp(-m/2)#
			if(i==A) lz[i,]=lz[i, ]/(1-(exp(-m/2)*oa[i,])*exp(-m/2))#
		}#
	}#
	#
	phif = sum(0.5*lz[, 1]*fa)		#fished female eggs per recruit#
	phiq = sum(0.5*lz*wa*qa)#
	print(phiq)#
	#
	re = max(ro*(kap-phie/phif)/(kap-1), 0)#
	be = re*phif#
	ye = fe*re*phiq#
	spr = phif/phie#
	#
	#
	#
	#
	#Graphics#
	if(show)#
	{#
		matplot(age, sa, type="l", xlim=c(0, 20),xlab="Age", ylab="Selectivity")#
		matplot(age, la, type="o")#
		matplot(age, wa, type="o")#
		matlines(age, fa, type="l", col=3)#
		matplot(age, lx, type="l",xlab="Age", ylab="Survivorship")#
		matlines(age, lz, col=3:4)#
	}#
	#
	return(list(ye=ye, re=re, be=be, spr=spr))#
}#
show=TRUE#
equil.age(theta, 0)#
show=FALSE#
fe=seq(0,0.5,by=0.001)#
ee=as.data.frame(t(sapply(fe,equil.age,theta=theta)))#
ye=unlist(ee[,1])#
re=unlist(ee[,2])#
be=unlist(ee[,3])#
spr=unlist(ee[,4])#
#
imsy= which(ye==max(ye))#
#
plot(fe,ye, type="l",xlab="Umsy", ylab="Yield")#
text(median(fe),ye[imsy],paste("Umsy =", fe[imsy],"\nMSY =", round(ye[imsy], 0)), pos=1)#
plot(fe,re, type="l")#
text(median(fe),ro, paste("Ro =",ro), pos=3)#
plot(fe,be, type="l")#
text(fe[imsy],be[imsy], paste("Bmsy =",round(be[imsy], 0)), pos=4)#
plot(fe,spr, type="l")#
#
#
print(paste("Fmsy =", fe[imsy]))#
print(paste("MSY =", round(ye[imsy], 0)))#
print(paste("Rmsy =", round(re[imsy], 0)))#
print(paste("Bmsy =", round(be[imsy], 0)))#
print(paste("SPRmsy =", round(spr[imsy], 3)))
setwd('/Users/stevenmartell/Documents/REVIEWS/POP Assessment')
#POPReview.R#
#
#Equilibrium sex structured model to explore reference points#
#for the POP assessment.#
#
#s = index for sex 1=females,  2=males#
A=60  #age of plus group.#
age=1:A#
s=1:2#
show=T#
discrete=T#
#PARAMETERS#
ro		<- 20507#
h		<- 0.754#
kap		<- 4*h/(1-h)#
m		<- c(0.067, 0.073)#
mu		<- 12.4#
delta	<- 0.39#
log.vl	<- 3.52#
linf	<- c(45.11, 41.62)#
k		<- c(0.1404, 0.1675)#
to		<- c(-1.3035, -1.0210)#
a		<- c(9.26e-6, 8.13e-6)#
b		<- c(3.116, 3.155)#
ma		<- c(0, 0, 0, 0, 0.023, #
			0.034, 0.096, 0.211, 0.341, 0.465, #
			0.601, 0.738, 0.860, 0.950, 0.996, #
			rep(1.000,length=45))#
#
theta=list(ro=ro, h=h, m=m, mu=mu, delta=delta, log.vl=log.vl, #
			linf=linf, k=k, to=to, a=a, b=b, ma=ma)#
#
#PROCEDURES#
par(mfcol=c(2, 2))#
equil.age <- function(theta, fe=0)#
{#
	#Double logistic selectivity#
	sa = exp(-(age-mu)^2/exp(log.vl))  #female#
	sa = cbind(sa,exp(-(age-mu+delta)^2/exp(log.vl)) )  #male baseed on delta offset#
	sa[age>mu, 1]=1#
	sa[age>(mu+delta), 2]=1#
	#
	#
	#Growth#
	la=sapply(s, function(s)linf[s]*(1-exp(-k[s]*(age-to[s]))))#
	wa=sapply(s, function(s)a[s]*la[,s]^b[s])#
	fa=ma*wa[,1]#
	#
	#
	#Incidence functions#
	lx = sapply(s, function(s) exp(-m[s])^(age-1))#
	lx[A,]=lx[A,]/(1-exp(-m))	#plus group#
	phie = sum(0.5*lx[,1]*fa)		#female eggs per recruit#
	#
	#
	#Stock recruitment parameters for beverton-holt model#
	so=kap/phie#
	beta=(kap-1)/(ro*phie)#
	#
	lz = matrix(0, nrow=A, ncol=2)#
	#Fished conditions (instantaneous rates)#
	#fe=0.0#
	za = t(m + fe*t(sa))#
	oa = 1-exp(-za)#
	qa = (sa/za)*oa#
	#
	lz[1, ] = 1.0#
	for(i in 2:A)#
	{#
		lz[i,] = lz[i-1, ]*exp(-za[i-1, ])#
		if(i==A) lz[i,]=lz[i, ]/(1-exp(-za[i, ]))#
	}#
	#
	#Fished conditions (discrete rates)#
	if(discrete){#
		lz[i, ] = 1.0#
		oa = (1-t(fe*t(sa)))#
		qa=sa#
		for(i in 2:A)#
		{#
			lz[i, ]=(lz[i-1, ]*exp(-m/2)*oa[i,])*exp(-m/2)#
			if(i==A) lz[i,]=lz[i, ]/(1-(exp(-m/2)*oa[i,])*exp(-m/2))#
		}#
	}#
	#
	phif = sum(0.5*lz[, 1]*fa)		#fished female eggs per recruit#
	phiq = sum(0.5*lz*wa*qa)#
	print(phiq)#
	#
	re = max(ro*(kap-phie/phif)/(kap-1), 0)#
	be = re*phif#
	ye = fe*re*phiq#
	spr = phif/phie#
	#
	#
	#
	#
	#Graphics#
	if(show)#
	{#
		matplot(age, sa, type="l", xlim=c(0, 20),xlab="Age", ylab="Selectivity")#
		matplot(age, la, type="o")#
		matplot(age, wa, type="o")#
		matlines(age, fa, type="l", col=3)#
		matplot(age, lx, type="l",xlab="Age", ylab="Survivorship")#
		matlines(age, lz, col=3:4)#
	}#
	#
	return(list(ye=ye, re=re, be=be, spr=spr))#
}#
show=TRUE#
equil.age(theta, 0)#
show=FALSE#
fe=seq(0,0.5,by=0.001)#
ee=as.data.frame(t(sapply(fe,equil.age,theta=theta)))#
ye=unlist(ee[,1])#
re=unlist(ee[,2])#
be=unlist(ee[,3])#
spr=unlist(ee[,4])#
#
imsy= which(ye==max(ye))#
#
plot(fe,ye, type="l",xlab="Umsy", ylab="Yield")#
text(median(fe),ye[imsy],paste("Umsy =", fe[imsy],"\nMSY =", round(ye[imsy], 0)), pos=1)#
plot(fe,re, type="l")#
text(median(fe),ro, paste("Ro =",ro), pos=3)#
plot(fe,be, type="l")#
text(fe[imsy],be[imsy], paste("Bmsy =",round(be[imsy], 0)), pos=4)#
plot(fe,spr, type="l")#
text(fe[imsy],spr[imsy], paste("SPR at MSY =",round(spr[imsy], 0)), pos=4)#
#
#
print(paste("Fmsy =", fe[imsy]))#
print(paste("MSY =", round(ye[imsy], 0)))#
print(paste("Rmsy =", round(re[imsy], 0)))#
print(paste("Bmsy =", round(be[imsy], 0)))#
print(paste("SPRmsy =", round(spr[imsy], 3)))
setwd('/Users/stevenmartell/Documents/REVIEWS/POP Assessment')
#POPReview.R#
#
#Equilibrium sex structured model to explore reference points#
#for the POP assessment.#
#
#s = index for sex 1=females,  2=males#
A=60  #age of plus group.#
age=1:A#
s=1:2#
show=T#
discrete=T#
#PARAMETERS#
ro		<- 20507#
h		<- 0.754#
kap		<- 4*h/(1-h)#
m		<- c(0.067, 0.073)#
mu		<- 12.4#
delta	<- 0.39#
log.vl	<- 3.52#
linf	<- c(45.11, 41.62)#
k		<- c(0.1404, 0.1675)#
to		<- c(-1.3035, -1.0210)#
a		<- c(9.26e-6, 8.13e-6)#
b		<- c(3.116, 3.155)#
ma		<- c(0, 0, 0, 0, 0.023, #
			0.034, 0.096, 0.211, 0.341, 0.465, #
			0.601, 0.738, 0.860, 0.950, 0.996, #
			rep(1.000,length=45))#
#
theta=list(ro=ro, h=h, m=m, mu=mu, delta=delta, log.vl=log.vl, #
			linf=linf, k=k, to=to, a=a, b=b, ma=ma)#
#
#PROCEDURES#
par(mfcol=c(2, 2))#
equil.age <- function(theta, fe=0)#
{#
	#Double logistic selectivity#
	sa = exp(-(age-mu)^2/exp(log.vl))  #female#
	sa = cbind(sa,exp(-(age-mu+delta)^2/exp(log.vl)) )  #male baseed on delta offset#
	sa[age>mu, 1]=1#
	sa[age>(mu+delta), 2]=1#
	#
	#
	#Growth#
	la=sapply(s, function(s)linf[s]*(1-exp(-k[s]*(age-to[s]))))#
	wa=sapply(s, function(s)a[s]*la[,s]^b[s])#
	fa=ma*wa[,1]#
	#
	#
	#Incidence functions#
	lx = sapply(s, function(s) exp(-m[s])^(age-1))#
	lx[A,]=lx[A,]/(1-exp(-m))	#plus group#
	phie = sum(0.5*lx[,1]*fa)		#female eggs per recruit#
	#
	#
	#Stock recruitment parameters for beverton-holt model#
	so=kap/phie#
	beta=(kap-1)/(ro*phie)#
	#
	lz = matrix(0, nrow=A, ncol=2)#
	#Fished conditions (instantaneous rates)#
	#fe=0.0#
	za = t(m + fe*t(sa))#
	oa = 1-exp(-za)#
	qa = (sa/za)*oa#
	#
	lz[1, ] = 1.0#
	for(i in 2:A)#
	{#
		lz[i,] = lz[i-1, ]*exp(-za[i-1, ])#
		if(i==A) lz[i,]=lz[i, ]/(1-exp(-za[i, ]))#
	}#
	#
	#Fished conditions (discrete rates)#
	if(discrete){#
		lz[i, ] = 1.0#
		oa = (1-t(fe*t(sa)))#
		qa=sa#
		for(i in 2:A)#
		{#
			lz[i, ]=(lz[i-1, ]*exp(-m/2)*oa[i,])*exp(-m/2)#
			if(i==A) lz[i,]=lz[i, ]/(1-(exp(-m/2)*oa[i,])*exp(-m/2))#
		}#
	}#
	#
	phif = sum(0.5*lz[, 1]*fa)		#fished female eggs per recruit#
	phiq = sum(0.5*lz*wa*qa)#
	print(phiq)#
	#
	re = max(ro*(kap-phie/phif)/(kap-1), 0)#
	be = re*phif#
	ye = fe*re*phiq#
	spr = phif/phie#
	#
	#
	#
	#
	#Graphics#
	if(show)#
	{#
		matplot(age, sa, type="l", xlim=c(0, 20),xlab="Age", ylab="Selectivity")#
		matplot(age, la, type="o")#
		matplot(age, wa, type="o")#
		matlines(age, fa, type="l", col=3)#
		matplot(age, lx, type="l",xlab="Age", ylab="Survivorship")#
		matlines(age, lz, col=3:4)#
	}#
	#
	return(list(ye=ye, re=re, be=be, spr=spr))#
}#
show=TRUE#
equil.age(theta, 0)#
show=FALSE#
fe=seq(0,0.5,by=0.001)#
ee=as.data.frame(t(sapply(fe,equil.age,theta=theta)))#
ye=unlist(ee[,1])#
re=unlist(ee[,2])#
be=unlist(ee[,3])#
spr=unlist(ee[,4])#
#
imsy= which(ye==max(ye))#
#
plot(fe,ye, type="l",xlab="Umsy", ylab="Yield")#
text(median(fe),ye[imsy],paste("Umsy =", fe[imsy],"\nMSY =", round(ye[imsy], 0)), pos=1)#
plot(fe,re, type="l")#
text(median(fe),ro, paste("Ro =",ro), pos=3)#
plot(fe,be, type="l")#
text(fe[imsy],be[imsy], paste("Bmsy =",round(be[imsy], 0)), pos=4)#
plot(fe,spr, type="l")#
text(fe[imsy],spr[imsy], paste("SPR at MSY =",round(spr[imsy], 3)), pos=4)#
#
#
print(paste("Fmsy =", fe[imsy]))#
print(paste("MSY =", round(ye[imsy], 0)))#
print(paste("Rmsy =", round(re[imsy], 0)))#
print(paste("Bmsy =", round(be[imsy], 0)))#
print(paste("SPRmsy =", round(spr[imsy], 3)))
setwd('/Users/stevenmartell/Documents/REVIEWS/POP Assessment')
#POPReview.R#
#
#Equilibrium sex structured model to explore reference points#
#for the POP assessment.#
#
#s = index for sex 1=females,  2=males#
A=60  #age of plus group.#
age=1:A#
s=1:2#
show=T#
discrete=T#
#PARAMETERS#
ro		<- 20507#
h		<- 0.754#
kap		<- 4*h/(1-h)#
m		<- c(0.067, 0.073)#
mu		<- 12.4#
delta	<- 0.39#
log.vl	<- 3.52#
linf	<- c(45.11, 41.62)#
k		<- c(0.1404, 0.1675)#
to		<- c(-1.3035, -1.0210)#
a		<- c(9.26e-6, 8.13e-6)#
b		<- c(3.116, 3.155)#
ma		<- c(0, 0, 0, 0, 0.023, #
			0.034, 0.096, 0.211, 0.341, 0.465, #
			0.601, 0.738, 0.860, 0.950, 0.996, #
			rep(1.000,length=45))#
#
theta=list(ro=ro, h=h, m=m, mu=mu, delta=delta, log.vl=log.vl, #
			linf=linf, k=k, to=to, a=a, b=b, ma=ma)#
#
#PROCEDURES#
par(mfcol=c(2, 2))#
equil.age <- function(theta, fe=0)#
{#
	#Double logistic selectivity#
	sa = exp(-(age-mu)^2/exp(log.vl))  #female#
	sa = cbind(sa,exp(-(age-mu+delta)^2/exp(log.vl)) )  #male baseed on delta offset#
	sa[age>mu, 1]=1#
	sa[age>(mu+delta), 2]=1#
	#
	#
	#Growth#
	la=sapply(s, function(s)linf[s]*(1-exp(-k[s]*(age-to[s]))))#
	wa=sapply(s, function(s)a[s]*la[,s]^b[s])#
	fa=ma*wa[,1]#
	#
	#
	#Incidence functions#
	lx = sapply(s, function(s) exp(-m[s])^(age-1))#
	lx[A,]=lx[A,]/(1-exp(-m))	#plus group#
	phie = sum(0.5*lx[,1]*fa)		#female eggs per recruit#
	#
	#
	#Stock recruitment parameters for beverton-holt model#
	so=kap/phie#
	beta=(kap-1)/(ro*phie)#
	#
	lz = matrix(0, nrow=A, ncol=2)#
	#Fished conditions (instantaneous rates)#
	#fe=0.0#
	za = t(m + fe*t(sa))#
	oa = 1-exp(-za)#
	qa = (sa/za)*oa#
	#
	lz[1, ] = 1.0#
	for(i in 2:A)#
	{#
		lz[i,] = lz[i-1, ]*exp(-za[i-1, ])#
		if(i==A) lz[i,]=lz[i, ]/(1-exp(-za[i, ]))#
	}#
	#
	#Fished conditions (discrete rates)#
	if(discrete){#
		lz[i, ] = 1.0#
		oa = (1-t(fe*t(sa)))#
		qa=sa#
		for(i in 2:A)#
		{#
			lz[i, ]=(lz[i-1, ]*exp(-m/2)*oa[i,])*exp(-m/2)#
			if(i==A) lz[i,]=lz[i, ]/(1-(exp(-m/2)*oa[i,])*exp(-m/2))#
		}#
	}#
	#
	phif = sum(0.5*lz[, 1]*fa)		#fished female eggs per recruit#
	phiq = sum(0.5*lz*wa*qa)#
	print(phiq)#
	#
	re = max(ro*(kap-phie/phif)/(kap-1), 0)#
	be = re*phif#
	ye = fe*re*phiq#
	spr = phif/phie#
	#
	#
	#
	#
	#Graphics#
	if(show)#
	{#
		matplot(age, sa, type="l", xlim=c(0, 20),xlab="Age", ylab="Selectivity")#
		matplot(age, la, type="o")#
		matplot(age, wa, type="o")#
		matlines(age, fa, type="l", col=3)#
		matplot(age, lx, type="l",xlab="Age", ylab="Survivorship")#
		matlines(age, lz, col=3:4)#
	}#
	#
	return(list(ye=ye, re=re, be=be, spr=spr))#
}#
show=TRUE#
equil.age(theta, 0)#
show=FALSE#
fe=seq(0,0.5,by=0.001)#
ee=as.data.frame(t(sapply(fe,equil.age,theta=theta)))#
ye=unlist(ee[,1])#
re=unlist(ee[,2])#
be=unlist(ee[,3])#
spr=unlist(ee[,4])#
#
imsy= which(ye==max(ye))#
#
plot(fe,ye, type="l",xlab="Umsy", ylab="Yield")#
text(median(fe),ye[imsy],paste("Umsy =", fe[imsy],"\nMSY =", round(ye[imsy], 0)), pos=1)#
plot(fe,re, type="l",xlab="Umsy", ylab="Age-1 recruits")#
text(median(fe),ro, paste("Ro =",ro), pos=3)#
plot(fe,be, type="l",xlab="Umsy", ylab="Female biomass")#
text(fe[imsy],be[imsy], paste("Bmsy =",round(be[imsy], 0)), pos=4)#
plot(fe,spr, type="l",xlab="Umsy", ylab="SPR")#
text(fe[imsy],spr[imsy], paste("SPR at MSY =",round(spr[imsy], 3)), pos=4)#
#
#
print(paste("Fmsy =", fe[imsy]))#
print(paste("MSY =", round(ye[imsy], 0)))#
print(paste("Rmsy =", round(re[imsy], 0)))#
print(paste("Bmsy =", round(be[imsy], 0)))#
print(paste("SPRmsy =", round(spr[imsy], 3)))
setwd('/Users/stevenmartell/Documents/REVIEWS/POP Assessment')
#POPReview.R#
#
#Equilibrium sex structured model to explore reference points#
#for the POP assessment.#
#
#s = index for sex 1=females,  2=males#
A=60  #age of plus group.#
age=1:A#
s=1:2#
show=T#
discrete=T#
#PARAMETERS#
ro		<- 20507#
h		<- 0.754#
kap		<- 4*h/(1-h)#
m		<- c(0.067, 0.073)#
mu		<- 12.4#
delta	<- 0.39#
log.vl	<- 3.52#
linf	<- c(45.11, 41.62)#
k		<- c(0.1404, 0.1675)#
to		<- c(-1.3035, -1.0210)#
a		<- c(9.26e-6, 8.13e-6)#
b		<- c(3.116, 3.155)#
ma		<- c(0, 0, 0, 0, 0.023, #
			0.034, 0.096, 0.211, 0.341, 0.465, #
			0.601, 0.738, 0.860, 0.950, 0.996, #
			rep(1.000,length=45))#
#
theta=list(ro=ro, h=h, m=m, mu=mu, delta=delta, log.vl=log.vl, #
			linf=linf, k=k, to=to, a=a, b=b, ma=ma)#
#
#PROCEDURES#
par(mfcol=c(2, 2))#
equil.age <- function(theta, fe=0)#
{#
	#Double logistic selectivity#
	sa = exp(-(age-mu)^2/exp(log.vl))  #female#
	sa = cbind(sa,exp(-(age-mu+delta)^2/exp(log.vl)) )  #male baseed on delta offset#
	sa[age>mu, 1]=1#
	sa[age>(mu+delta), 2]=1#
	#
	#
	#Growth#
	la=sapply(s, function(s)linf[s]*(1-exp(-k[s]*(age-to[s]))))#
	wa=sapply(s, function(s)a[s]*la[,s]^b[s])#
	fa=ma*wa[,1]#
	#
	#
	#Incidence functions#
	lx = sapply(s, function(s) exp(-m[s])^(age-1))#
	lx[A,]=lx[A,]/(1-exp(-m))	#plus group#
	phie = sum(0.5*lx[,1]*fa)		#female eggs per recruit#
	#
	#
	#Stock recruitment parameters for beverton-holt model#
	so=kap/phie#
	beta=(kap-1)/(ro*phie)#
	#
	lz = matrix(0, nrow=A, ncol=2)#
	#Fished conditions (instantaneous rates)#
	#fe=0.0#
	za = t(m + fe*t(sa))#
	oa = 1-exp(-za)#
	qa = (sa/za)*oa#
	#
	lz[1, ] = 1.0#
	for(i in 2:A)#
	{#
		lz[i,] = lz[i-1, ]*exp(-za[i-1, ])#
		if(i==A) lz[i,]=lz[i, ]/(1-exp(-za[i, ]))#
	}#
	#
	#Fished conditions (discrete rates)#
	if(discrete){#
		lz[i, ] = 1.0#
		oa = (1-t(fe*t(sa)))#
		qa=sa#
		for(i in 2:A)#
		{#
			lz[i, ]=(lz[i-1, ]*exp(-m/2)*oa[i,])*exp(-m/2)#
			if(i==A) lz[i,]=lz[i, ]/(1-(exp(-m/2)*oa[i,])*exp(-m/2))#
		}#
	}#
	#
	phif = sum(0.5*lz[, 1]*fa)		#fished female eggs per recruit#
	phiq = sum(0.5*lz*wa*qa)#
	print(phiq)#
	#
	re = max(ro*(kap-phie/phif)/(kap-1), 0)#
	be = re*phif#
	ye = fe*re*phiq#
	spr = phif/phie#
	#
	#
	#
	#
	#Graphics#
	if(show)#
	{#
		matplot(age, sa, type="l", xlim=c(0, 20),xlab="Age", ylab="Selectivity")#
		matplot(age, la, type="o")#
		matplot(age, wa, type="o")#
		matlines(age, fa, type="l", col=3)#
		matplot(age, lx, type="l",xlab="Age", ylab="Survivorship")#
		matlines(age, lz, col=3:4)#
	}#
	#
	return(list(ye=ye, re=re, be=be, spr=spr))#
}#
show=TRUE#
equil.age(theta, 0)#
show=FALSE#
fe=seq(0,0.5,by=0.001)#
ee=as.data.frame(t(sapply(fe,equil.age,theta=theta)))#
ye=unlist(ee[,1])#
re=unlist(ee[,2])#
be=unlist(ee[,3])#
spr=unlist(ee[,4])#
#
imsy= which(ye==max(ye))#
#
plot(fe,ye, type="l",xlab="Umsy", ylab="Yield")#
text(median(fe),ye[imsy],paste("Umsy =", fe[imsy],"\nMSY =", round(ye[imsy], 0)), pos=1)#
segments(fe[imsy],0, fe[imsy], ye[imsy])#
plot(fe,re, type="l",xlab="Umsy", ylab="Age-1 recruits")#
text(median(fe),ro, paste("Ro =",ro), pos=3)#
plot(fe,be, type="l",xlab="Umsy", ylab="Female biomass")#
text(fe[imsy],be[imsy], paste("Bmsy =",round(be[imsy], 0)), pos=4)#
plot(fe,spr, type="l",xlab="Umsy", ylab="SPR")#
text(fe[imsy],spr[imsy], paste("SPR at MSY =",round(spr[imsy], 3)), pos=4)#
#
#
print(paste("Fmsy =", fe[imsy]))#
print(paste("MSY =", round(ye[imsy], 0)))#
print(paste("Rmsy =", round(re[imsy], 0)))#
print(paste("Bmsy =", round(be[imsy], 0)))#
print(paste("SPRmsy =", round(spr[imsy], 3)))
setwd('/Users/stevenmartell/Documents/REVIEWS/POP Assessment')
#POPReview.R#
#
#Equilibrium sex structured model to explore reference points#
#for the POP assessment.#
#
#s = index for sex 1=females,  2=males#
A=60  #age of plus group.#
age=1:A#
s=1:2#
show=T#
discrete=T#
#PARAMETERS#
ro		<- 20507#
h		<- 0.754#
kap		<- 4*h/(1-h)#
m		<- c(0.067, 0.073)#
mu		<- 12.4#
delta	<- 0.39#
log.vl	<- 3.52#
linf	<- c(45.11, 41.62)#
k		<- c(0.1404, 0.1675)#
to		<- c(-1.3035, -1.0210)#
a		<- c(9.26e-6, 8.13e-6)#
b		<- c(3.116, 3.155)#
ma		<- c(0, 0, 0, 0, 0.023, #
			0.034, 0.096, 0.211, 0.341, 0.465, #
			0.601, 0.738, 0.860, 0.950, 0.996, #
			rep(1.000,length=45))#
#
theta=list(ro=ro, h=h, m=m, mu=mu, delta=delta, log.vl=log.vl, #
			linf=linf, k=k, to=to, a=a, b=b, ma=ma)#
#
#PROCEDURES#
par(mfcol=c(2, 2))#
equil.age <- function(theta, fe=0)#
{#
	#Double logistic selectivity#
	sa = exp(-(age-mu)^2/exp(log.vl))  #female#
	sa = cbind(sa,exp(-(age-mu+delta)^2/exp(log.vl)) )  #male baseed on delta offset#
	sa[age>mu, 1]=1#
	sa[age>(mu+delta), 2]=1#
	#
	#
	#Growth#
	la=sapply(s, function(s)linf[s]*(1-exp(-k[s]*(age-to[s]))))#
	wa=sapply(s, function(s)a[s]*la[,s]^b[s])#
	fa=ma*wa[,1]#
	#
	#
	#Incidence functions#
	lx = sapply(s, function(s) exp(-m[s])^(age-1))#
	lx[A,]=lx[A,]/(1-exp(-m))	#plus group#
	phie = sum(0.5*lx[,1]*fa)		#female eggs per recruit#
	#
	#
	#Stock recruitment parameters for beverton-holt model#
	so=kap/phie#
	beta=(kap-1)/(ro*phie)#
	#
	lz = matrix(0, nrow=A, ncol=2)#
	#Fished conditions (instantaneous rates)#
	#fe=0.0#
	za = t(m + fe*t(sa))#
	oa = 1-exp(-za)#
	qa = (sa/za)*oa#
	#
	lz[1, ] = 1.0#
	for(i in 2:A)#
	{#
		lz[i,] = lz[i-1, ]*exp(-za[i-1, ])#
		if(i==A) lz[i,]=lz[i, ]/(1-exp(-za[i, ]))#
	}#
	#
	#Fished conditions (discrete rates)#
	if(discrete){#
		lz[i, ] = 1.0#
		oa = (1-t(fe*t(sa)))#
		qa=sa#
		for(i in 2:A)#
		{#
			lz[i, ]=(lz[i-1, ]*exp(-m/2)*oa[i,])*exp(-m/2)#
			if(i==A) lz[i,]=lz[i, ]/(1-(exp(-m/2)*oa[i,])*exp(-m/2))#
		}#
	}#
	#
	phif = sum(0.5*lz[, 1]*fa)		#fished female eggs per recruit#
	phiq = sum(0.5*lz*wa*qa)#
	print(phiq)#
	#
	re = max(ro*(kap-phie/phif)/(kap-1), 0)#
	be = re*phif#
	ye = fe*re*phiq#
	spr = phif/phie#
	#
	#
	#
	#
	#Graphics#
	if(show)#
	{#
		matplot(age, sa, type="l", xlim=c(0, 20),xlab="Age", ylab="Selectivity")#
		matplot(age, la, type="o")#
		matplot(age, wa, type="o")#
		matlines(age, fa, type="l", col=3)#
		matplot(age, lx, type="l",xlab="Age", ylab="Survivorship")#
		matlines(age, lz, col=3:4)#
	}#
	#
	return(list(ye=ye, re=re, be=be, spr=spr))#
}#
show=TRUE#
equil.age(theta, 0)#
show=FALSE#
fe=seq(0,0.5,by=0.001)#
ee=as.data.frame(t(sapply(fe,equil.age,theta=theta)))#
ye=unlist(ee[,1])#
re=unlist(ee[,2])#
be=unlist(ee[,3])#
spr=unlist(ee[,4])#
#
imsy= which(ye==max(ye))#
#
plot(fe,ye, type="l",xlab="Umsy", ylab="Yield")#
text(median(fe),ye[imsy],paste("Umsy =", fe[imsy],"\nMSY =", round(ye[imsy], 0)), pos=1)#
segments(fe[imsy],0, fe[imsy], ye[imsy],col="grey",lty=2)#
segments(0,ye[imsy], fe[imsy], ye[imsy],col="grey",lty=2)#
plot(fe,re, type="l",xlab="Umsy", ylab="Age-1 recruits")#
text(median(fe),ro, paste("Ro =",ro), pos=3)#
plot(fe,be, type="l",xlab="Umsy", ylab="Female biomass")#
text(fe[imsy],be[imsy], paste("Bmsy =",round(be[imsy], 0)), pos=4)#
plot(fe,spr, type="l",xlab="Umsy", ylab="SPR")#
text(fe[imsy],spr[imsy], paste("SPR at MSY =",round(spr[imsy], 3)), pos=4)#
#
#
print(paste("Fmsy =", fe[imsy]))#
print(paste("MSY =", round(ye[imsy], 0)))#
print(paste("Rmsy =", round(re[imsy], 0)))#
print(paste("Bmsy =", round(be[imsy], 0)))#
print(paste("SPRmsy =", round(spr[imsy], 3)))
setwd('/Users/stevenmartell/Documents/REVIEWS/POP Assessment')
#POPReview.R#
#
#Equilibrium sex structured model to explore reference points#
#for the POP assessment.#
#
#s = index for sex 1=females,  2=males#
A=60  #age of plus group.#
age=1:A#
s=1:2#
show=T#
discrete=T#
#PARAMETERS#
ro		<- 20507#
h		<- 0.754#
kap		<- 4*h/(1-h)#
m		<- c(0.067, 0.073)#
mu		<- 12.4#
delta	<- 0.39#
log.vl	<- 3.52#
linf	<- c(45.11, 41.62)#
k		<- c(0.1404, 0.1675)#
to		<- c(-1.3035, -1.0210)#
a		<- c(9.26e-6, 8.13e-6)#
b		<- c(3.116, 3.155)#
ma		<- c(0, 0, 0, 0, 0.023, #
			0.034, 0.096, 0.211, 0.341, 0.465, #
			0.601, 0.738, 0.860, 0.950, 0.996, #
			rep(1.000,length=45))#
#
theta=list(ro=ro, h=h, m=m, mu=mu, delta=delta, log.vl=log.vl, #
			linf=linf, k=k, to=to, a=a, b=b, ma=ma)#
#
#PROCEDURES#
par(mfcol=c(2, 2))#
equil.age <- function(theta, fe=0)#
{#
	#Double logistic selectivity#
	sa = exp(-(age-mu)^2/exp(log.vl))  #female#
	sa = cbind(sa,exp(-(age-mu+delta)^2/exp(log.vl)) )  #male baseed on delta offset#
	sa[age>mu, 1]=1#
	sa[age>(mu+delta), 2]=1#
	#
	#
	#Growth#
	la=sapply(s, function(s)linf[s]*(1-exp(-k[s]*(age-to[s]))))#
	wa=sapply(s, function(s)a[s]*la[,s]^b[s])#
	fa=ma*wa[,1]#
	#
	#
	#Incidence functions#
	lx = sapply(s, function(s) exp(-m[s])^(age-1))#
	lx[A,]=lx[A,]/(1-exp(-m))	#plus group#
	phie = sum(0.5*lx[,1]*fa)		#female eggs per recruit#
	#
	#
	#Stock recruitment parameters for beverton-holt model#
	so=kap/phie#
	beta=(kap-1)/(ro*phie)#
	#
	lz = matrix(0, nrow=A, ncol=2)#
	#Fished conditions (instantaneous rates)#
	#fe=0.0#
	za = t(m + fe*t(sa))#
	oa = 1-exp(-za)#
	qa = (sa/za)*oa#
	#
	lz[1, ] = 1.0#
	for(i in 2:A)#
	{#
		lz[i,] = lz[i-1, ]*exp(-za[i-1, ])#
		if(i==A) lz[i,]=lz[i, ]/(1-exp(-za[i, ]))#
	}#
	#
	#Fished conditions (discrete rates)#
	if(discrete){#
		lz[i, ] = 1.0#
		oa = (1-t(fe*t(sa)))#
		qa=sa#
		for(i in 2:A)#
		{#
			lz[i, ]=(lz[i-1, ]*exp(-m/2)*oa[i,])*exp(-m/2)#
			if(i==A) lz[i,]=lz[i, ]/(1-(exp(-m/2)*oa[i,])*exp(-m/2))#
		}#
	}#
	#
	phif = sum(0.5*lz[, 1]*fa)		#fished female eggs per recruit#
	phiq = sum(0.5*lz*wa*qa)#
	print(phiq)#
	#
	re = max(ro*(kap-phie/phif)/(kap-1), 0)#
	be = re*phif#
	ye = fe*re*phiq#
	spr = phif/phie#
	#
	#
	#
	#
	#Graphics#
	if(show)#
	{#
		matplot(age, sa, type="l", xlim=c(0, 20),xlab="Age", ylab="Selectivity")#
		matplot(age, la, type="o")#
		matplot(age, wa, type="o")#
		matlines(age, fa, type="l", col=3)#
		matplot(age, lx, type="l",xlab="Age", ylab="Survivorship")#
		matlines(age, lz, col=3:4)#
	}#
	#
	return(list(ye=ye, re=re, be=be, spr=spr))#
}#
show=TRUE#
equil.age(theta, 0)#
show=FALSE#
fe=seq(0,0.5,by=0.001)#
ee=as.data.frame(t(sapply(fe,equil.age,theta=theta)))#
ye=unlist(ee[,1])#
re=unlist(ee[,2])#
be=unlist(ee[,3])#
spr=unlist(ee[,4])#
#
imsy= which(ye==max(ye))#
#
plot(fe,ye, type="l",xlab="Umsy", ylab="Yield")#
text(median(fe),ye[imsy],paste("Umsy =", fe[imsy],"\nMSY =", round(ye[imsy], 0)), pos=1)#
segments(fe[imsy],0, fe[imsy], ye[imsy],col="grey",lty=2)#
segments(0,ye[imsy], fe[imsy], ye[imsy],col="grey",lty=2)#
#
plot(fe,re, type="l",xlab="Umsy", ylab="Age-1 recruits")#
segments(fe[imsy],0, fe[imsy], re[imsy],col="grey",lty=2)#
segments(0,re[imsy], fe[imsy], re[imsy],col="grey",lty=2)#
#
text(median(fe),ro, paste("Ro =",ro), pos=3)#
plot(fe,be, type="l",xlab="Umsy", ylab="Female biomass")#
text(fe[imsy],be[imsy], paste("Bmsy =",round(be[imsy], 0)), pos=4)#
plot(fe,spr, type="l",xlab="Umsy", ylab="SPR")#
text(fe[imsy],spr[imsy], paste("SPR at MSY =",round(spr[imsy], 3)), pos=4)#
#
#
print(paste("Fmsy =", fe[imsy]))#
print(paste("MSY =", round(ye[imsy], 0)))#
print(paste("Rmsy =", round(re[imsy], 0)))#
print(paste("Bmsy =", round(be[imsy], 0)))#
print(paste("SPRmsy =", round(spr[imsy], 3)))
setwd('/Users/stevenmartell/Documents/REVIEWS/POP Assessment')
#POPReview.R#
#
#Equilibrium sex structured model to explore reference points#
#for the POP assessment.#
#
#s = index for sex 1=females,  2=males#
A=60  #age of plus group.#
age=1:A#
s=1:2#
show=T#
discrete=T#
#PARAMETERS#
ro		<- 20507#
h		<- 0.754#
kap		<- 4*h/(1-h)#
m		<- c(0.067, 0.073)#
mu		<- 12.4#
delta	<- 0.39#
log.vl	<- 3.52#
linf	<- c(45.11, 41.62)#
k		<- c(0.1404, 0.1675)#
to		<- c(-1.3035, -1.0210)#
a		<- c(9.26e-6, 8.13e-6)#
b		<- c(3.116, 3.155)#
ma		<- c(0, 0, 0, 0, 0.023, #
			0.034, 0.096, 0.211, 0.341, 0.465, #
			0.601, 0.738, 0.860, 0.950, 0.996, #
			rep(1.000,length=45))#
#
theta=list(ro=ro, h=h, m=m, mu=mu, delta=delta, log.vl=log.vl, #
			linf=linf, k=k, to=to, a=a, b=b, ma=ma)#
#
#PROCEDURES#
par(mfcol=c(2, 2))#
equil.age <- function(theta, fe=0)#
{#
	#Double logistic selectivity#
	sa = exp(-(age-mu)^2/exp(log.vl))  #female#
	sa = cbind(sa,exp(-(age-mu+delta)^2/exp(log.vl)) )  #male baseed on delta offset#
	sa[age>mu, 1]=1#
	sa[age>(mu+delta), 2]=1#
	#
	#
	#Growth#
	la=sapply(s, function(s)linf[s]*(1-exp(-k[s]*(age-to[s]))))#
	wa=sapply(s, function(s)a[s]*la[,s]^b[s])#
	fa=ma*wa[,1]#
	#
	#
	#Incidence functions#
	lx = sapply(s, function(s) exp(-m[s])^(age-1))#
	lx[A,]=lx[A,]/(1-exp(-m))	#plus group#
	phie = sum(0.5*lx[,1]*fa)		#female eggs per recruit#
	#
	#
	#Stock recruitment parameters for beverton-holt model#
	so=kap/phie#
	beta=(kap-1)/(ro*phie)#
	#
	lz = matrix(0, nrow=A, ncol=2)#
	#Fished conditions (instantaneous rates)#
	#fe=0.0#
	za = t(m + fe*t(sa))#
	oa = 1-exp(-za)#
	qa = (sa/za)*oa#
	#
	lz[1, ] = 1.0#
	for(i in 2:A)#
	{#
		lz[i,] = lz[i-1, ]*exp(-za[i-1, ])#
		if(i==A) lz[i,]=lz[i, ]/(1-exp(-za[i, ]))#
	}#
	#
	#Fished conditions (discrete rates)#
	if(discrete){#
		lz[i, ] = 1.0#
		oa = (1-t(fe*t(sa)))#
		qa=sa#
		for(i in 2:A)#
		{#
			lz[i, ]=(lz[i-1, ]*exp(-m/2)*oa[i,])*exp(-m/2)#
			if(i==A) lz[i,]=lz[i, ]/(1-(exp(-m/2)*oa[i,])*exp(-m/2))#
		}#
	}#
	#
	phif = sum(0.5*lz[, 1]*fa)		#fished female eggs per recruit#
	phiq = sum(0.5*lz*wa*qa)#
	print(phiq)#
	#
	re = max(ro*(kap-phie/phif)/(kap-1), 0)#
	be = re*phif#
	ye = fe*re*phiq#
	spr = phif/phie#
	#
	#
	#
	#
	#Graphics#
	if(show)#
	{#
		matplot(age, sa, type="l", xlim=c(0, 20),xlab="Age", ylab="Selectivity")#
		matplot(age, la, type="o")#
		matplot(age, wa, type="o")#
		matlines(age, fa, type="l", col=3)#
		matplot(age, lx, type="l",xlab="Age", ylab="Survivorship")#
		matlines(age, lz, col=3:4)#
	}#
	#
	return(list(ye=ye, re=re, be=be, spr=spr))#
}#
show=TRUE#
equil.age(theta, 0)#
show=FALSE#
fe=seq(0,0.5,by=0.001)#
ee=as.data.frame(t(sapply(fe,equil.age,theta=theta)))#
ye=unlist(ee[,1])#
re=unlist(ee[,2])#
be=unlist(ee[,3])#
spr=unlist(ee[,4])#
#
imsy= which(ye==max(ye))#
#
plot(fe,ye, type="l",xlab="Umsy", ylab="Yield")#
text(median(fe),ye[imsy],paste("Umsy =", fe[imsy],"\nMSY =", round(ye[imsy], 0)), pos=1)#
segments(fe[imsy],0, fe[imsy], ye[imsy],col="grey",lty=2)#
segments(0,ye[imsy], fe[imsy], ye[imsy],col="grey",lty=2)#
#
plot(fe,re, type="l",xlab="Umsy", ylab="Age-1 recruits")#
text(median(fe),ro, paste("Ro =",ro), pos=3)#
segments(fe[imsy],0, fe[imsy], re[imsy],col="grey",lty=2)#
segments(0,re[imsy], fe[imsy], re[imsy],col="grey",lty=2)#
#
#
plot(fe,be/be[1], type="l",xlab="Umsy", ylab="Female biomass depletion")#
text(fe[imsy],be[imsy], paste("Bmsy =",round(be[imsy], 0)), pos=4)#
segments(fe[imsy],0, fe[imsy], be[imsy]/be[1],col="grey",lty=2)#
segments(0,be[imsy]/be[1], fe[imsy], be[imsy]/be[1],col="grey",lty=2)#
#
plot(fe,spr, type="l",xlab="Umsy", ylab="SPR")#
text(fe[imsy],spr[imsy], paste("SPR at MSY =",round(spr[imsy], 3)), pos=4)#
#
#
print(paste("Fmsy =", fe[imsy]))#
print(paste("MSY =", round(ye[imsy], 0)))#
print(paste("Rmsy =", round(re[imsy], 0)))#
print(paste("Bmsy =", round(be[imsy], 0)))#
print(paste("SPRmsy =", round(spr[imsy], 3)))
setwd('/Users/stevenmartell/Documents/REVIEWS/POP Assessment')
#POPReview.R#
#
#Equilibrium sex structured model to explore reference points#
#for the POP assessment.#
#
#s = index for sex 1=females,  2=males#
A=60  #age of plus group.#
age=1:A#
s=1:2#
show=T#
discrete=T#
#PARAMETERS#
ro		<- 20507#
h		<- 0.754#
kap		<- 4*h/(1-h)#
m		<- c(0.067, 0.073)#
mu		<- 12.4#
delta	<- 0.39#
log.vl	<- 3.52#
linf	<- c(45.11, 41.62)#
k		<- c(0.1404, 0.1675)#
to		<- c(-1.3035, -1.0210)#
a		<- c(9.26e-6, 8.13e-6)#
b		<- c(3.116, 3.155)#
ma		<- c(0, 0, 0, 0, 0.023, #
			0.034, 0.096, 0.211, 0.341, 0.465, #
			0.601, 0.738, 0.860, 0.950, 0.996, #
			rep(1.000,length=45))#
#
theta=list(ro=ro, h=h, m=m, mu=mu, delta=delta, log.vl=log.vl, #
			linf=linf, k=k, to=to, a=a, b=b, ma=ma)#
#
#PROCEDURES#
par(mfcol=c(2, 2))#
equil.age <- function(theta, fe=0)#
{#
	#Double logistic selectivity#
	sa = exp(-(age-mu)^2/exp(log.vl))  #female#
	sa = cbind(sa,exp(-(age-mu+delta)^2/exp(log.vl)) )  #male baseed on delta offset#
	sa[age>mu, 1]=1#
	sa[age>(mu+delta), 2]=1#
	#
	#
	#Growth#
	la=sapply(s, function(s)linf[s]*(1-exp(-k[s]*(age-to[s]))))#
	wa=sapply(s, function(s)a[s]*la[,s]^b[s])#
	fa=ma*wa[,1]#
	#
	#
	#Incidence functions#
	lx = sapply(s, function(s) exp(-m[s])^(age-1))#
	lx[A,]=lx[A,]/(1-exp(-m))	#plus group#
	phie = sum(0.5*lx[,1]*fa)		#female eggs per recruit#
	#
	#
	#Stock recruitment parameters for beverton-holt model#
	so=kap/phie#
	beta=(kap-1)/(ro*phie)#
	#
	lz = matrix(0, nrow=A, ncol=2)#
	#Fished conditions (instantaneous rates)#
	#fe=0.0#
	za = t(m + fe*t(sa))#
	oa = 1-exp(-za)#
	qa = (sa/za)*oa#
	#
	lz[1, ] = 1.0#
	for(i in 2:A)#
	{#
		lz[i,] = lz[i-1, ]*exp(-za[i-1, ])#
		if(i==A) lz[i,]=lz[i, ]/(1-exp(-za[i, ]))#
	}#
	#
	#Fished conditions (discrete rates)#
	if(discrete){#
		lz[i, ] = 1.0#
		oa = (1-t(fe*t(sa)))#
		qa=sa#
		for(i in 2:A)#
		{#
			lz[i, ]=(lz[i-1, ]*exp(-m/2)*oa[i,])*exp(-m/2)#
			if(i==A) lz[i,]=lz[i, ]/(1-(exp(-m/2)*oa[i,])*exp(-m/2))#
		}#
	}#
	#
	phif = sum(0.5*lz[, 1]*fa)		#fished female eggs per recruit#
	phiq = sum(0.5*lz*wa*qa)#
	print(phiq)#
	#
	re = max(ro*(kap-phie/phif)/(kap-1), 0)#
	be = re*phif#
	ye = fe*re*phiq#
	spr = phif/phie#
	#
	#
	#
	#
	#Graphics#
	if(show)#
	{#
		matplot(age, sa, type="l", xlim=c(0, 20),xlab="Age", ylab="Selectivity")#
		matplot(age, la, type="o")#
		matplot(age, wa, type="o")#
		matlines(age, fa, type="l", col=3)#
		matplot(age, lx, type="l",xlab="Age", ylab="Survivorship")#
		matlines(age, lz, col=3:4)#
	}#
	#
	return(list(ye=ye, re=re, be=be, spr=spr))#
}#
show=TRUE#
equil.age(theta, 0)#
show=FALSE#
fe=seq(0,0.5,by=0.001)#
ee=as.data.frame(t(sapply(fe,equil.age,theta=theta)))#
ye=unlist(ee[,1])#
re=unlist(ee[,2])#
be=unlist(ee[,3])#
spr=unlist(ee[,4])#
#
imsy= which(ye==max(ye))#
#
plot(fe,ye, type="l",xlab="Umsy", ylab="Yield")#
text(median(fe),ye[imsy],paste("Umsy =", fe[imsy],"\nMSY =", round(ye[imsy], 0)), pos=1)#
segments(fe[imsy],0, fe[imsy], ye[imsy],col="grey",lty=2)#
segments(0,ye[imsy], fe[imsy], ye[imsy],col="grey",lty=2)#
#
plot(fe,re, type="l",xlab="Umsy", ylab="Age-1 recruits")#
text(median(fe),ro, paste("Ro =",ro), pos=3)#
segments(fe[imsy],0, fe[imsy], re[imsy],col="grey",lty=2)#
segments(0,re[imsy], fe[imsy], re[imsy],col="grey",lty=2)#
#
#
plot(fe,be/be[1], type="l",xlab="Umsy", ylab="Female biomass depletion")#
text(fe[imsy],be[imsy]/be[1], paste("Bmsy/Bo =",round(be[imsy]/be[1], 0)), pos=4)#
segments(fe[imsy],0, fe[imsy], be[imsy]/be[1],col="grey",lty=2)#
segments(0,be[imsy]/be[1], fe[imsy], be[imsy]/be[1],col="grey",lty=2)#
#
plot(fe,spr, type="l",xlab="Umsy", ylab="SPR")#
text(fe[imsy],spr[imsy], paste("SPR at MSY =",round(spr[imsy], 3)), pos=4)#
#
#
print(paste("Fmsy =", fe[imsy]))#
print(paste("MSY =", round(ye[imsy], 0)))#
print(paste("Rmsy =", round(re[imsy], 0)))#
print(paste("Bmsy =", round(be[imsy], 0)))#
print(paste("SPRmsy =", round(spr[imsy], 3)))
setwd('/Users/stevenmartell/Documents/REVIEWS/POP Assessment')
#POPReview.R#
#
#Equilibrium sex structured model to explore reference points#
#for the POP assessment.#
#
#s = index for sex 1=females,  2=males#
A=60  #age of plus group.#
age=1:A#
s=1:2#
show=T#
discrete=T#
#PARAMETERS#
ro		<- 20507#
h		<- 0.754#
kap		<- 4*h/(1-h)#
m		<- c(0.067, 0.073)#
mu		<- 12.4#
delta	<- 0.39#
log.vl	<- 3.52#
linf	<- c(45.11, 41.62)#
k		<- c(0.1404, 0.1675)#
to		<- c(-1.3035, -1.0210)#
a		<- c(9.26e-6, 8.13e-6)#
b		<- c(3.116, 3.155)#
ma		<- c(0, 0, 0, 0, 0.023, #
			0.034, 0.096, 0.211, 0.341, 0.465, #
			0.601, 0.738, 0.860, 0.950, 0.996, #
			rep(1.000,length=45))#
#
theta=list(ro=ro, h=h, m=m, mu=mu, delta=delta, log.vl=log.vl, #
			linf=linf, k=k, to=to, a=a, b=b, ma=ma)#
#
#PROCEDURES#
par(mfcol=c(2, 2))#
equil.age <- function(theta, fe=0)#
{#
	#Double logistic selectivity#
	sa = exp(-(age-mu)^2/exp(log.vl))  #female#
	sa = cbind(sa,exp(-(age-mu+delta)^2/exp(log.vl)) )  #male baseed on delta offset#
	sa[age>mu, 1]=1#
	sa[age>(mu+delta), 2]=1#
	#
	#
	#Growth#
	la=sapply(s, function(s)linf[s]*(1-exp(-k[s]*(age-to[s]))))#
	wa=sapply(s, function(s)a[s]*la[,s]^b[s])#
	fa=ma*wa[,1]#
	#
	#
	#Incidence functions#
	lx = sapply(s, function(s) exp(-m[s])^(age-1))#
	lx[A,]=lx[A,]/(1-exp(-m))	#plus group#
	phie = sum(0.5*lx[,1]*fa)		#female eggs per recruit#
	#
	#
	#Stock recruitment parameters for beverton-holt model#
	so=kap/phie#
	beta=(kap-1)/(ro*phie)#
	#
	lz = matrix(0, nrow=A, ncol=2)#
	#Fished conditions (instantaneous rates)#
	#fe=0.0#
	za = t(m + fe*t(sa))#
	oa = 1-exp(-za)#
	qa = (sa/za)*oa#
	#
	lz[1, ] = 1.0#
	for(i in 2:A)#
	{#
		lz[i,] = lz[i-1, ]*exp(-za[i-1, ])#
		if(i==A) lz[i,]=lz[i, ]/(1-exp(-za[i, ]))#
	}#
	#
	#Fished conditions (discrete rates)#
	if(discrete){#
		lz[i, ] = 1.0#
		oa = (1-t(fe*t(sa)))#
		qa=sa#
		for(i in 2:A)#
		{#
			lz[i, ]=(lz[i-1, ]*exp(-m/2)*oa[i,])*exp(-m/2)#
			if(i==A) lz[i,]=lz[i, ]/(1-(exp(-m/2)*oa[i,])*exp(-m/2))#
		}#
	}#
	#
	phif = sum(0.5*lz[, 1]*fa)		#fished female eggs per recruit#
	phiq = sum(0.5*lz*wa*qa)#
	print(phiq)#
	#
	re = max(ro*(kap-phie/phif)/(kap-1), 0)#
	be = re*phif#
	ye = fe*re*phiq#
	spr = phif/phie#
	#
	#
	#
	#
	#Graphics#
	if(show)#
	{#
		matplot(age, sa, type="l", xlim=c(0, 20),xlab="Age", ylab="Selectivity")#
		matplot(age, la, type="o")#
		matplot(age, wa, type="o")#
		matlines(age, fa, type="l", col=3)#
		matplot(age, lx, type="l",xlab="Age", ylab="Survivorship")#
		matlines(age, lz, col=3:4)#
	}#
	#
	return(list(ye=ye, re=re, be=be, spr=spr))#
}#
show=TRUE#
equil.age(theta, 0)#
show=FALSE#
fe=seq(0,0.5,by=0.001)#
ee=as.data.frame(t(sapply(fe,equil.age,theta=theta)))#
ye=unlist(ee[,1])#
re=unlist(ee[,2])#
be=unlist(ee[,3])#
spr=unlist(ee[,4])#
#
imsy= which(ye==max(ye))#
#
plot(fe,ye, type="l",xlab="Umsy", ylab="Yield")#
text(median(fe),ye[imsy],paste("Umsy =", fe[imsy],"\nMSY =", round(ye[imsy], 0)), pos=1)#
segments(fe[imsy],0, fe[imsy], ye[imsy],col="grey",lty=2)#
segments(0,ye[imsy], fe[imsy], ye[imsy],col="grey",lty=2)#
#
plot(fe,re, type="l",xlab="Umsy", ylab="Age-1 recruits")#
text(median(fe),ro, paste("Ro =",ro), pos=3)#
segments(fe[imsy],0, fe[imsy], re[imsy],col="grey",lty=2)#
segments(0,re[imsy], fe[imsy], re[imsy],col="grey",lty=2)#
#
#
plot(fe,be/be[1], type="l",xlab="Umsy", ylab="Female biomass depletion")#
text(fe[imsy],be[imsy]/be[1], paste("Bmsy/Bo =",round(be[imsy]/be[1], 3)), pos=4)#
segments(fe[imsy],0, fe[imsy], be[imsy]/be[1],col="grey",lty=2)#
segments(0,be[imsy]/be[1], fe[imsy], be[imsy]/be[1],col="grey",lty=2)#
#
plot(fe,spr, type="l",xlab="Umsy", ylab="SPR")#
text(fe[imsy],spr[imsy], paste("SPR at MSY =",round(spr[imsy], 3)), pos=4)#
#
#
print(paste("Fmsy =", fe[imsy]))#
print(paste("MSY =", round(ye[imsy], 0)))#
print(paste("Rmsy =", round(re[imsy], 0)))#
print(paste("Bmsy =", round(be[imsy], 0)))#
print(paste("SPRmsy =", round(spr[imsy], 3)))
setwd('/Users/stevenmartell/Documents/REVIEWS/POP Assessment')
#POPReview.R#
#
#Equilibrium sex structured model to explore reference points#
#for the POP assessment.#
#
#s = index for sex 1=females,  2=males#
A=60  #age of plus group.#
age=1:A#
s=1:2#
show=T#
discrete=T#
#PARAMETERS#
ro		<- 20507#
h		<- 0.754#
kap		<- 4*h/(1-h)#
m		<- c(0.067, 0.073)#
mu		<- 12.4#
delta	<- 0.39#
log.vl	<- 3.52#
linf	<- c(45.11, 41.62)#
k		<- c(0.1404, 0.1675)#
to		<- c(-1.3035, -1.0210)#
a		<- c(9.26e-6, 8.13e-6)#
b		<- c(3.116, 3.155)#
ma		<- c(0, 0, 0, 0, 0.023, #
			0.034, 0.096, 0.211, 0.341, 0.465, #
			0.601, 0.738, 0.860, 0.950, 0.996, #
			rep(1.000,length=45))#
#
theta=list(ro=ro, h=h, m=m, mu=mu, delta=delta, log.vl=log.vl, #
			linf=linf, k=k, to=to, a=a, b=b, ma=ma)#
#
#PROCEDURES#
par(mfcol=c(2, 2))#
equil.age <- function(theta, fe=0)#
{#
	#Double logistic selectivity#
	sa = exp(-(age-mu)^2/exp(log.vl))  #female#
	sa = cbind(sa,exp(-(age-mu+delta)^2/exp(log.vl)) )  #male baseed on delta offset#
	sa[age>mu, 1]=1#
	sa[age>(mu+delta), 2]=1#
	#
	#
	#Growth#
	la=sapply(s, function(s)linf[s]*(1-exp(-k[s]*(age-to[s]))))#
	wa=sapply(s, function(s)a[s]*la[,s]^b[s])#
	fa=ma*wa[,1]#
	#
	#
	#Incidence functions#
	lx = sapply(s, function(s) exp(-m[s])^(age-1))#
	lx[A,]=lx[A,]/(1-exp(-m))	#plus group#
	phie = sum(0.5*lx[,1]*fa)		#female eggs per recruit#
	#
	#
	#Stock recruitment parameters for beverton-holt model#
	so=kap/phie#
	beta=(kap-1)/(ro*phie)#
	#
	lz = matrix(0, nrow=A, ncol=2)#
	#Fished conditions (instantaneous rates)#
	#fe=0.0#
	za = t(m + fe*t(sa))#
	oa = 1-exp(-za)#
	qa = (sa/za)*oa#
	#
	lz[1, ] = 1.0#
	for(i in 2:A)#
	{#
		lz[i,] = lz[i-1, ]*exp(-za[i-1, ])#
		if(i==A) lz[i,]=lz[i, ]/(1-exp(-za[i, ]))#
	}#
	#
	#Fished conditions (discrete rates)#
	if(discrete){#
		lz[i, ] = 1.0#
		oa = (1-t(fe*t(sa)))#
		qa=sa#
		for(i in 2:A)#
		{#
			lz[i, ]=(lz[i-1, ]*exp(-m/2)*oa[i,])*exp(-m/2)#
			if(i==A) lz[i,]=lz[i, ]/(1-(exp(-m/2)*oa[i,])*exp(-m/2))#
		}#
	}#
	#
	phif = sum(0.5*lz[, 1]*fa)		#fished female eggs per recruit#
	phiq = sum(0.5*lz*wa*qa)#
	print(phiq)#
	#
	re = max(ro*(kap-phie/phif)/(kap-1), 0)#
	be = re*phif#
	ye = fe*re*phiq#
	spr = phif/phie#
	#
	#
	#
	#
	#Graphics#
	if(show)#
	{#
		matplot(age, sa, type="l", xlim=c(0, 20),xlab="Age", ylab="Selectivity")#
		matplot(age, la, type="o")#
		matplot(age, wa, type="o")#
		matlines(age, fa, type="l", col=3)#
		matplot(age, lx, type="l",xlab="Age", ylab="Survivorship")#
		matlines(age, lz, col=3:4)#
	}#
	#
	return(list(ye=ye, re=re, be=be, spr=spr))#
}#
show=TRUE#
equil.age(theta, 0)#
show=FALSE#
fe=seq(0,0.5,by=0.001)#
ee=as.data.frame(t(sapply(fe,equil.age,theta=theta)))#
ye=unlist(ee[,1])#
re=unlist(ee[,2])#
be=unlist(ee[,3])#
spr=unlist(ee[,4])#
#
imsy= which(ye==max(ye))#
#
plot(fe,ye, type="l",xlab="Umsy", ylab="Yield")#
text(median(fe),ye[imsy],paste("Umsy =", fe[imsy],"\nMSY =", round(ye[imsy], 0)), pos=1)#
segments(fe[imsy],0, fe[imsy], ye[imsy],col="grey",lty=2)#
segments(0,ye[imsy], fe[imsy], ye[imsy],col="grey",lty=2)#
#
plot(fe,re, type="l",xlab="Umsy", ylab="Age-1 recruits")#
text(median(fe),ro, paste("Ro =",ro), pos=3)#
segments(fe[imsy],0, fe[imsy], re[imsy],col="grey",lty=2)#
segments(0,re[imsy], fe[imsy], re[imsy],col="grey",lty=2)#
#
#
plot(fe,be/be[1], type="l",xlab="Umsy", ylab="Female biomass depletion")#
text(fe[imsy],be[imsy]/be[1], paste("Bmsy/Bo =",round(be[imsy]/be[1], 3)), pos=4)#
segments(fe[imsy],0, fe[imsy], be[imsy]/be[1],col="grey",lty=2)#
segments(0,be[imsy]/be[1], fe[imsy], be[imsy]/be[1],col="grey",lty=2)#
#
plot(fe,spr, type="l",xlab="Umsy", ylab="SPR")#
text(fe[imsy],spr[imsy], paste("SPR at MSY =",round(spr[imsy], 3)), pos=4)#
segments(fe[imsy],0, fe[imsy], spr[imsy],col="grey",lty=2)#
segments(0,spr[imsy], fe[imsy], spr[imsy],col="grey",lty=2)#
#
#
print(paste("Fmsy =", fe[imsy]))#
print(paste("MSY =", round(ye[imsy], 0)))#
print(paste("Rmsy =", round(re[imsy], 0)))#
print(paste("Bmsy =", round(be[imsy], 0)))#
print(paste("SPRmsy =", round(spr[imsy], 3)))
setwd('/Users/stevenmartell/Documents/REVIEWS/POP Assessment')
#POPReview.R#
#
#Equilibrium sex structured model to explore reference points#
#for the POP assessment.#
#
#s = index for sex 1=females,  2=males#
A=60  #age of plus group.#
age=1:A#
s=1:2#
show=T#
discrete=T#
#PARAMETERS#
ro		<- 20507#
h		<- 0.754#
kap		<- 4*h/(1-h)#
m		<- c(0.067, 0.073)#
mu		<- 12.4#
delta	<- 0.39#
log.vl	<- 3.52#
linf	<- c(45.11, 41.62)#
k		<- c(0.1404, 0.1675)#
to		<- c(-1.3035, -1.0210)#
a		<- c(9.26e-6, 8.13e-6)#
b		<- c(3.116, 3.155)#
ma		<- c(0, 0, 0, 0, 0.023, #
			0.034, 0.096, 0.211, 0.341, 0.465, #
			0.601, 0.738, 0.860, 0.950, 0.996, #
			rep(1.000,length=45))#
#
theta=list(ro=ro, h=h, m=m, mu=mu, delta=delta, log.vl=log.vl, #
			linf=linf, k=k, to=to, a=a, b=b, ma=ma)#
#
#PROCEDURES#
par(mfcol=c(2, 2))#
equil.age <- function(theta, fe=0)#
{#
	#Double logistic selectivity#
	sa = exp(-(age-mu)^2/exp(log.vl))  #female#
	sa = cbind(sa,exp(-(age-mu+delta)^2/exp(log.vl)) )  #male baseed on delta offset#
	sa[age>mu, 1]=1#
	sa[age>(mu+delta), 2]=1#
	#
	#
	#Growth#
	la=sapply(s, function(s)linf[s]*(1-exp(-k[s]*(age-to[s]))))#
	wa=sapply(s, function(s)a[s]*la[,s]^b[s])#
	fa=ma*wa[,1]#
	#
	#
	#Incidence functions#
	lx = sapply(s, function(s) exp(-m[s])^(age-1))#
	lx[A,]=lx[A,]/(1-exp(-m))	#plus group#
	phie = sum(0.5*lx[,1]*fa)		#female eggs per recruit#
	#
	#
	#Stock recruitment parameters for beverton-holt model#
	so=kap/phie#
	beta=(kap-1)/(ro*phie)#
	#
	lz = matrix(0, nrow=A, ncol=2)#
	#Fished conditions (instantaneous rates)#
	#fe=0.0#
	za = t(m + fe*t(sa))#
	oa = 1-exp(-za)#
	qa = (sa/za)*oa#
	#
	lz[1, ] = 1.0#
	for(i in 2:A)#
	{#
		lz[i,] = lz[i-1, ]*exp(-za[i-1, ])#
		if(i==A) lz[i,]=lz[i, ]/(1-exp(-za[i, ]))#
	}#
	#
	#Fished conditions (discrete rates)#
	if(discrete){#
		lz[i, ] = 1.0#
		oa = (1-t(fe*t(sa)))#
		qa=sa#
		for(i in 2:A)#
		{#
			lz[i, ]=(lz[i-1, ]*exp(-m/2)*oa[i,])*exp(-m/2)#
			if(i==A) lz[i,]=lz[i, ]/(1-(exp(-m/2)*oa[i,])*exp(-m/2))#
		}#
	}#
	#
	phif = sum(0.5*lz[, 1]*fa)		#fished female eggs per recruit#
	phiq = sum(0.5*lz*wa*qa)#
	print(phiq)#
	#
	re = max(ro*(kap-phie/phif)/(kap-1), 0)#
	be = re*phif#
	ye = fe*re*phiq#
	spr = phif/phie#
	#
	#
	#
	#
	#Graphics#
	if(show)#
	{#
		matplot(age, sa, type="l", xlim=c(0, 20),xlab="Age", ylab="Selectivity")#
		matplot(age, la, type="o")#
		matplot(age, wa, type="o")#
		matlines(age, fa, type="l", col=3)#
		matplot(age, lx, type="l",xlab="Age", ylab="Survivorship")#
		matlines(age, lz, col=3:4)#
	}#
	#
	return(list(ye=ye, re=re, be=be, spr=spr))#
}#
show=TRUE#
equil.age(theta, 0)#
show=FALSE#
fe=seq(0,0.3,by=0.001)#
ee=as.data.frame(t(sapply(fe,equil.age,theta=theta)))#
ye=unlist(ee[,1])#
re=unlist(ee[,2])#
be=unlist(ee[,3])#
spr=unlist(ee[,4])#
#
imsy= which(ye==max(ye))#
#
plot(fe,ye, type="l",xlab="Umsy", ylab="Yield")#
text(median(fe),ye[imsy],paste("Umsy =", fe[imsy],"\nMSY =", round(ye[imsy], 0)), pos=1)#
segments(fe[imsy],0, fe[imsy], ye[imsy],col="grey",lty=2)#
segments(0,ye[imsy], fe[imsy], ye[imsy],col="grey",lty=2)#
#
plot(fe,re, type="l",xlab="Umsy", ylab="Age-1 recruits")#
text(median(fe),re[imsy], paste("Ro =",ro), pos=3)#
segments(fe[imsy],0, fe[imsy], re[imsy],col="grey",lty=2)#
segments(0,re[imsy], fe[imsy], re[imsy],col="grey",lty=2)#
#
#
plot(fe,be/be[1], type="l",xlab="Umsy", ylab="Female biomass depletion")#
text(fe[imsy],be[imsy]/be[1], paste("Bmsy/Bo =",round(be[imsy]/be[1], 3)), pos=4)#
segments(fe[imsy],0, fe[imsy], be[imsy]/be[1],col="grey",lty=2)#
segments(0,be[imsy]/be[1], fe[imsy], be[imsy]/be[1],col="grey",lty=2)#
#
plot(fe,spr, type="l",xlab="Umsy", ylab="SPR")#
text(fe[imsy],spr[imsy], paste("SPR at MSY =",round(spr[imsy], 3)), pos=4)#
segments(fe[imsy],0, fe[imsy], spr[imsy],col="grey",lty=2)#
segments(0,spr[imsy], fe[imsy], spr[imsy],col="grey",lty=2)#
#
#
print(paste("Fmsy =", fe[imsy]))#
print(paste("MSY =", round(ye[imsy], 0)))#
print(paste("Rmsy =", round(re[imsy], 0)))#
print(paste("Bmsy =", round(be[imsy], 0)))#
print(paste("SPRmsy =", round(spr[imsy], 3)))
setwd('/Users/stevenmartell/Documents/REVIEWS/POP Assessment')
#POPReview.R#
#
#Equilibrium sex structured model to explore reference points#
#for the POP assessment.#
#
#s = index for sex 1=females,  2=males#
A=60  #age of plus group.#
age=1:A#
s=1:2#
show=T#
discrete=T#
#PARAMETERS#
ro		<- 20507#
h		<- 0.754#
kap		<- 4*h/(1-h)#
m		<- c(0.067, 0.073)#
mu		<- 12.4#
delta	<- 0.39#
log.vl	<- 3.52#
linf	<- c(45.11, 41.62)#
k		<- c(0.1404, 0.1675)#
to		<- c(-1.3035, -1.0210)#
a		<- c(9.26e-6, 8.13e-6)#
b		<- c(3.116, 3.155)#
ma		<- c(0, 0, 0, 0, 0.023, #
			0.034, 0.096, 0.211, 0.341, 0.465, #
			0.601, 0.738, 0.860, 0.950, 0.996, #
			rep(1.000,length=45))#
#
theta=list(ro=ro, h=h, m=m, mu=mu, delta=delta, log.vl=log.vl, #
			linf=linf, k=k, to=to, a=a, b=b, ma=ma)#
#
#PROCEDURES#
par(mfcol=c(2, 2))#
equil.age <- function(theta, fe=0)#
{#
	#Double logistic selectivity#
	sa = exp(-(age-mu)^2/exp(log.vl))  #female#
	sa = cbind(sa,exp(-(age-mu+delta)^2/exp(log.vl)) )  #male baseed on delta offset#
	sa[age>mu, 1]=1#
	sa[age>(mu+delta), 2]=1#
	#
	#
	#Growth#
	la=sapply(s, function(s)linf[s]*(1-exp(-k[s]*(age-to[s]))))#
	wa=sapply(s, function(s)a[s]*la[,s]^b[s])#
	fa=ma*wa[,1]#
	#
	#
	#Incidence functions#
	lx = sapply(s, function(s) exp(-m[s])^(age-1))#
	lx[A,]=lx[A,]/(1-exp(-m))	#plus group#
	phie = sum(0.5*lx[,1]*fa)		#female eggs per recruit#
	#
	#
	#Stock recruitment parameters for beverton-holt model#
	so=kap/phie#
	beta=(kap-1)/(ro*phie)#
	#
	lz = matrix(0, nrow=A, ncol=2)#
	#Fished conditions (instantaneous rates)#
	#fe=0.0#
	za = t(m + fe*t(sa))#
	oa = 1-exp(-za)#
	qa = (sa/za)*oa#
	#
	lz[1, ] = 1.0#
	for(i in 2:A)#
	{#
		lz[i,] = lz[i-1, ]*exp(-za[i-1, ])#
		if(i==A) lz[i,]=lz[i, ]/(1-exp(-za[i, ]))#
	}#
	#
	#Fished conditions (discrete rates)#
	if(discrete){#
		lz[i, ] = 1.0#
		oa = (1-t(fe*t(sa)))#
		qa=sa#
		for(i in 2:A)#
		{#
			lz[i, ]=(lz[i-1, ]*exp(-m/2)*oa[i,])*exp(-m/2)#
			if(i==A) lz[i,]=lz[i, ]/(1-(exp(-m/2)*oa[i,])*exp(-m/2))#
		}#
	}#
	#
	phif = sum(0.5*lz[, 1]*fa)		#fished female eggs per recruit#
	phiq = sum(0.5*lz*wa*qa)#
	print(phiq)#
	#
	re = max(ro*(kap-phie/phif)/(kap-1), 0)#
	be = re*phif#
	ye = fe*re*phiq#
	spr = phif/phie#
	#
	#
	#
	#
	#Graphics#
	if(show)#
	{#
		matplot(age, sa, type="l", xlim=c(0, 20),xlab="Age", ylab="Selectivity")#
		matplot(age, la, type="o")#
		matplot(age, wa, type="o")#
		matlines(age, fa, type="l", col=3)#
		matplot(age, lx, type="l",xlab="Age", ylab="Survivorship")#
		matlines(age, lz, col=3:4)#
	}#
	#
	return(list(ye=ye, re=re, be=be, spr=spr))#
}#
show=TRUE#
equil.age(theta, 0)#
show=FALSE#
fe=seq(0,0.3,by=0.001)#
ee=as.data.frame(t(sapply(fe,equil.age,theta=theta)))#
ye=unlist(ee[,1])#
re=unlist(ee[,2])#
be=unlist(ee[,3])#
spr=unlist(ee[,4])#
#
imsy= which(ye==max(ye))#
#
plot(fe,ye, type="l",xlab="Umsy", ylab="Yield")#
text(median(fe),ye[imsy],paste("Umsy =", fe[imsy],"\nMSY =", round(ye[imsy], 0)), pos=1)#
segments(fe[imsy],0, fe[imsy], ye[imsy],col="grey",lty=2)#
segments(0,ye[imsy], fe[imsy], ye[imsy],col="grey",lty=2)#
#
plot(fe,re, type="l",xlab="Umsy", ylab="Age-1 recruits")#
text(median(fe),re[imsy], paste("Ro =",ro, "\nRmsy/Ro ="/re[imsy]/ro), pos=3)#
segments(fe[imsy],0, fe[imsy], re[imsy],col="grey",lty=2)#
segments(0,re[imsy], fe[imsy], re[imsy],col="grey",lty=2)#
#
#
plot(fe,be/be[1], type="l",xlab="Umsy", ylab="Female biomass depletion")#
text(fe[imsy],be[imsy]/be[1], paste("Bmsy/Bo =",round(be[imsy]/be[1], 3)), pos=4)#
segments(fe[imsy],0, fe[imsy], be[imsy]/be[1],col="grey",lty=2)#
segments(0,be[imsy]/be[1], fe[imsy], be[imsy]/be[1],col="grey",lty=2)#
#
plot(fe,spr, type="l",xlab="Umsy", ylab="SPR")#
text(fe[imsy],spr[imsy], paste("SPR at MSY =",round(spr[imsy], 3)), pos=4)#
segments(fe[imsy],0, fe[imsy], spr[imsy],col="grey",lty=2)#
segments(0,spr[imsy], fe[imsy], spr[imsy],col="grey",lty=2)#
#
#
print(paste("Fmsy =", fe[imsy]))#
print(paste("MSY =", round(ye[imsy], 0)))#
print(paste("Rmsy =", round(re[imsy], 0)))#
print(paste("Bmsy =", round(be[imsy], 0)))#
print(paste("SPRmsy =", round(spr[imsy], 3)))
setwd('/Users/stevenmartell/Documents/REVIEWS/POP Assessment')
#POPReview.R#
#
#Equilibrium sex structured model to explore reference points#
#for the POP assessment.#
#
#s = index for sex 1=females,  2=males#
A=60  #age of plus group.#
age=1:A#
s=1:2#
show=T#
discrete=T#
#PARAMETERS#
ro		<- 20507#
h		<- 0.754#
kap		<- 4*h/(1-h)#
m		<- c(0.067, 0.073)#
mu		<- 12.4#
delta	<- 0.39#
log.vl	<- 3.52#
linf	<- c(45.11, 41.62)#
k		<- c(0.1404, 0.1675)#
to		<- c(-1.3035, -1.0210)#
a		<- c(9.26e-6, 8.13e-6)#
b		<- c(3.116, 3.155)#
ma		<- c(0, 0, 0, 0, 0.023, #
			0.034, 0.096, 0.211, 0.341, 0.465, #
			0.601, 0.738, 0.860, 0.950, 0.996, #
			rep(1.000,length=45))#
#
theta=list(ro=ro, h=h, m=m, mu=mu, delta=delta, log.vl=log.vl, #
			linf=linf, k=k, to=to, a=a, b=b, ma=ma)#
#
#PROCEDURES#
par(mfcol=c(2, 2))#
equil.age <- function(theta, fe=0)#
{#
	#Double logistic selectivity#
	sa = exp(-(age-mu)^2/exp(log.vl))  #female#
	sa = cbind(sa,exp(-(age-mu+delta)^2/exp(log.vl)) )  #male baseed on delta offset#
	sa[age>mu, 1]=1#
	sa[age>(mu+delta), 2]=1#
	#
	#
	#Growth#
	la=sapply(s, function(s)linf[s]*(1-exp(-k[s]*(age-to[s]))))#
	wa=sapply(s, function(s)a[s]*la[,s]^b[s])#
	fa=ma*wa[,1]#
	#
	#
	#Incidence functions#
	lx = sapply(s, function(s) exp(-m[s])^(age-1))#
	lx[A,]=lx[A,]/(1-exp(-m))	#plus group#
	phie = sum(0.5*lx[,1]*fa)		#female eggs per recruit#
	#
	#
	#Stock recruitment parameters for beverton-holt model#
	so=kap/phie#
	beta=(kap-1)/(ro*phie)#
	#
	lz = matrix(0, nrow=A, ncol=2)#
	#Fished conditions (instantaneous rates)#
	#fe=0.0#
	za = t(m + fe*t(sa))#
	oa = 1-exp(-za)#
	qa = (sa/za)*oa#
	#
	lz[1, ] = 1.0#
	for(i in 2:A)#
	{#
		lz[i,] = lz[i-1, ]*exp(-za[i-1, ])#
		if(i==A) lz[i,]=lz[i, ]/(1-exp(-za[i, ]))#
	}#
	#
	#Fished conditions (discrete rates)#
	if(discrete){#
		lz[i, ] = 1.0#
		oa = (1-t(fe*t(sa)))#
		qa=sa#
		for(i in 2:A)#
		{#
			lz[i, ]=(lz[i-1, ]*exp(-m/2)*oa[i,])*exp(-m/2)#
			if(i==A) lz[i,]=lz[i, ]/(1-(exp(-m/2)*oa[i,])*exp(-m/2))#
		}#
	}#
	#
	phif = sum(0.5*lz[, 1]*fa)		#fished female eggs per recruit#
	phiq = sum(0.5*lz*wa*qa)#
	print(phiq)#
	#
	re = max(ro*(kap-phie/phif)/(kap-1), 0)#
	be = re*phif#
	ye = fe*re*phiq#
	spr = phif/phie#
	#
	#
	#
	#
	#Graphics#
	if(show)#
	{#
		matplot(age, sa, type="l", xlim=c(0, 20),xlab="Age", ylab="Selectivity")#
		matplot(age, la, type="o")#
		matplot(age, wa, type="o")#
		matlines(age, fa, type="l", col=3)#
		matplot(age, lx, type="l",xlab="Age", ylab="Survivorship")#
		matlines(age, lz, col=3:4)#
	}#
	#
	return(list(ye=ye, re=re, be=be, spr=spr))#
}#
show=TRUE#
equil.age(theta, 0)#
show=FALSE#
fe=seq(0,0.3,by=0.001)#
ee=as.data.frame(t(sapply(fe,equil.age,theta=theta)))#
ye=unlist(ee[,1])#
re=unlist(ee[,2])#
be=unlist(ee[,3])#
spr=unlist(ee[,4])#
#
imsy= which(ye==max(ye))#
#
plot(fe,ye, type="l",xlab="Umsy", ylab="Yield")#
text(median(fe),ye[imsy],paste("Umsy =", fe[imsy],"\nMSY =", round(ye[imsy], 0)), pos=1)#
segments(fe[imsy],0, fe[imsy], ye[imsy],col="grey",lty=2)#
segments(0,ye[imsy], fe[imsy], ye[imsy],col="grey",lty=2)#
#
plot(fe,re, type="l",xlab="Umsy", ylab="Age-1 recruits")#
text(median(fe),re[imsy], paste("Ro =",ro, "\nRmsy/Ro =", round(re[imsy]/ro, 3)), pos=3)#
segments(fe[imsy],0, fe[imsy], re[imsy],col="grey",lty=2)#
segments(0,re[imsy], fe[imsy], re[imsy],col="grey",lty=2)#
#
#
plot(fe,be/be[1], type="l",xlab="Umsy", ylab="Female biomass depletion")#
text(fe[imsy],be[imsy]/be[1], paste("Bmsy/Bo =",round(be[imsy]/be[1], 3)), pos=4)#
segments(fe[imsy],0, fe[imsy], be[imsy]/be[1],col="grey",lty=2)#
segments(0,be[imsy]/be[1], fe[imsy], be[imsy]/be[1],col="grey",lty=2)#
#
plot(fe,spr, type="l",xlab="Umsy", ylab="SPR")#
text(fe[imsy],spr[imsy], paste("SPR at MSY =",round(spr[imsy], 3)), pos=4)#
segments(fe[imsy],0, fe[imsy], spr[imsy],col="grey",lty=2)#
segments(0,spr[imsy], fe[imsy], spr[imsy],col="grey",lty=2)#
#
#
print(paste("Fmsy =", fe[imsy]))#
print(paste("MSY =", round(ye[imsy], 0)))#
print(paste("Rmsy =", round(re[imsy], 0)))#
print(paste("Bmsy =", round(be[imsy], 0)))#
print(paste("SPRmsy =", round(spr[imsy], 3)))
setwd('/Users/stevenmartell/Documents/REVIEWS/POP Assessment')
#POPReview.R#
#
#Equilibrium sex structured model to explore reference points#
#for the POP assessment.#
#
#s = index for sex 1=females,  2=males#
A=60  #age of plus group.#
age=1:A#
s=1:2#
show=T#
discrete=T#
#PARAMETERS#
ro		<- 20507#
h		<- 0.754#
kap		<- 4*h/(1-h)#
m		<- c(0.067, 0.073)#
mu		<- 12.4#
delta	<- 0.39#
log.vl	<- 3.52#
linf	<- c(45.11, 41.62)#
k		<- c(0.1404, 0.1675)#
to		<- c(-1.3035, -1.0210)#
a		<- c(9.26e-6, 8.13e-6)#
b		<- c(3.116, 3.155)#
ma		<- c(0, 0, 0, 0, 0.023, #
			0.034, 0.096, 0.211, 0.341, 0.465, #
			0.601, 0.738, 0.860, 0.950, 0.996, #
			rep(1.000,length=45))#
#
theta=list(ro=ro, h=h, m=m, mu=mu, delta=delta, log.vl=log.vl, #
			linf=linf, k=k, to=to, a=a, b=b, ma=ma)#
#
#PROCEDURES#
par(mfcol=c(2, 2))#
equil.age <- function(theta, fe=0)#
{#
	#Double logistic selectivity#
	sa = exp(-(age-mu)^2/exp(log.vl))  #female#
	sa = cbind(sa,exp(-(age-mu+delta)^2/exp(log.vl)) )  #male baseed on delta offset#
	sa[age>mu, 1]=1#
	sa[age>(mu+delta), 2]=1#
	#
	#
	#Growth#
	la=sapply(s, function(s)linf[s]*(1-exp(-k[s]*(age-to[s]))))#
	wa=sapply(s, function(s)a[s]*la[,s]^b[s])#
	fa=ma*wa[,1]#
	#
	#
	#Incidence functions#
	lx = sapply(s, function(s) exp(-m[s])^(age-1))#
	lx[A,]=lx[A,]/(1-exp(-m))	#plus group#
	phie = sum(0.5*lx[,1]*fa)		#female eggs per recruit#
	#
	#
	#Stock recruitment parameters for beverton-holt model#
	so=kap/phie#
	beta=(kap-1)/(ro*phie)#
	#
	lz = matrix(0, nrow=A, ncol=2)#
	#Fished conditions (instantaneous rates)#
	#fe=0.0#
	za = t(m + fe*t(sa))#
	oa = 1-exp(-za)#
	qa = (sa/za)*oa#
	#
	lz[1, ] = 1.0#
	for(i in 2:A)#
	{#
		lz[i,] = lz[i-1, ]*exp(-za[i-1, ])#
		if(i==A) lz[i,]=lz[i, ]/(1-exp(-za[i, ]))#
	}#
	#
	#Fished conditions (discrete rates)#
	if(discrete){#
		lz[i, ] = 1.0#
		oa = (1-t(fe*t(sa)))#
		qa=sa#
		for(i in 2:A)#
		{#
			lz[i, ]=(lz[i-1, ]*exp(-m/2)*oa[i,])*exp(-m/2)#
			if(i==A) lz[i,]=lz[i, ]/(1-(exp(-m/2)*oa[i,])*exp(-m/2))#
		}#
	}#
	#
	phif = sum(0.5*lz[, 1]*fa)		#fished female eggs per recruit#
	phiq = sum(0.5*lz*wa*qa)#
	print(phiq)#
	#
	re = max(ro*(kap-phie/phif)/(kap-1), 0)#
	be = re*phif#
	ye = fe*re*phiq#
	spr = phif/phie#
	#
	#
	#
	#
	#Graphics#
	if(show)#
	{#
		matplot(age, sa, type="l", xlim=c(0, 20),xlab="Age", ylab="Selectivity")#
		matplot(age, la, type="o")#
		matplot(age, wa, type="o")#
		matlines(age, fa, type="l", col=3)#
		matplot(age, lx, type="l",xlab="Age", ylab="Survivorship")#
		matlines(age, lz, col=3:4)#
	}#
	#
	return(list(ye=ye, re=re, be=be, spr=spr))#
}#
show=TRUE#
equil.age(theta, 0)#
show=FALSE#
fe=seq(0,0.3,by=0.001)#
ee=as.data.frame(t(sapply(fe,equil.age,theta=theta)))#
ye=unlist(ee[,1])#
re=unlist(ee[,2])#
be=unlist(ee[,3])#
spr=unlist(ee[,4])#
#
imsy= which(ye==max(ye))#
#
plot(fe,ye, type="l",xlab="Umsy", ylab="Yield")#
text(median(fe),ye[imsy],paste("Umsy =", fe[imsy],"\nMSY =", round(ye[imsy], 0)), pos=1)#
segments(fe[imsy],0, fe[imsy], ye[imsy],col="grey",lty=2)#
segments(0,ye[imsy], fe[imsy], ye[imsy],col="grey",lty=2)#
#
plot(fe,re, type="l",xlab="Umsy", ylab="Age-1 recruits")#
text(median(fe),re[imsy], paste("Ro =",ro, "\nRmsy/Ro =", round(re[imsy]/ro, 3)), pos=3)#
segments(fe[imsy],0, fe[imsy], re[imsy],col="grey",lty=2)#
segments(0,re[imsy], fe[imsy], re[imsy],col="grey",lty=2)#
#
#
plot(fe,be/be[1], type="l",xlab="Umsy", ylab="Female biomass depletion")#
text(fe[imsy],be[imsy]/be[1], paste("Bmsy/Bo =",round(be[imsy]/be[1], 3)), pos=4)#
segments(fe[imsy],0, fe[imsy], be[imsy]/be[1],col="grey",lty=2)#
segments(0,be[imsy]/be[1], fe[imsy], be[imsy]/be[1],col="grey",lty=2)#
#
plot(fe,spr, type="l",xlab="Umsy", ylab="SPR")#
text(fe[imsy],spr[imsy], paste("SPR at MSY =",round(spr[imsy], 3)), pos=4)#
segments(fe[imsy],0, fe[imsy], spr[imsy],col="grey",lty=2)#
segments(0,spr[imsy], fe[imsy], spr[imsy],col="grey",lty=2)#
dev.copy2eps(file="Equil.age.eps")#
#
print(paste("Fmsy =", fe[imsy]))#
print(paste("MSY =", round(ye[imsy], 0)))#
print(paste("Rmsy =", round(re[imsy], 0)))#
print(paste("Bmsy =", round(be[imsy], 0)))#
print(paste("SPRmsy =", round(spr[imsy], 3)))
dir()
q()
setwd('/Users/stevenmartell/Documents/CONSULTING/BC Herring Assessment/hcam01Sep10PSARC-Final')
#------------------------------------------------------------------------------##
# (c) HCAM Viewer: Gui-based Viewer Widget for HCAM output, Version 1.0        ##
#                                                                              ##
#     Copyright 2008, 2009 by A.R. Kronlund, Jaclyn Cleary                     ##
#                                                                              ##
#     This software comes with ABSOLUTELY NO WARRANTY, expressed or implied.   ##
#     You have been provided with a copy of mseR for educational purposes.     ##
#     You are requested not to redistribute this software without seeking      ##
#     permission from the authors.                                             ##
#                                                                              ##
#     Of course, comments and suggestions for improvement greedily accepted.   ##
#                                                                              ##
#      "Pretty good management will do."  Bill de la Mare, Dec. 19, 2006.      ##
#                                                                              ##
#          "Success consists of going from failure to failure without          ##
#                  loss of enthusiasm."  Winston Churchill.                    ##
#                                                                              ##
#------------------ mseRguiTemplate.r: mseR GUI Functions ---------------------##
#--                                                                          --##
#-- hcamGuiFuns.r: A template for developing a graphical user                --##
#--                interface (GUI) for herring HCAM model outputs.           --##
#--                                                                          --##
#-- Authors: A.R. Kronlund (Pacific Biological Station, Nanaimo, B.C.)       --##
#--          J.S. Cleary (Pacific Biological Station, Nanaimo, B.C.)         --##
#--                                                                          --##
#-- Change Log:                                                              --##
#--                                                                          --##
#-- ARK: 15-Apr-09 (4.0 hrs) 1st implementation from mseR V2.0.              --##
#-- ARK: 22-Jun-09 19:00 to 22:00 (3.0 hrs) Modifications as per Jac         --##
#-- ARK: 25-Jun-09 05:30 to 07:00 (1.5 hrs) Added MCMC trace plots.          --##
#-- ARK: 26-Jun-09 21:00 to 23:00 (2.0 hrs) Added MCMC density plots.        --##
#-- ARK: 27-Jun-09 06:00 to 08:00 (2.0 hrs) Added MCMC pairs plots.          --##
#-- ARK: 27-Jun-09 10:00 to 11:15 (1.5 hrs) Added Excel functions.           --##
#-- ARK: 28-Jun-09 06:30 to 08:00 (1.5 hrs) Added cohort lines to PAA.       --##
#-- ARK: 28-Jun-09 14:30 to 16:00 (1.5 hrs) Added new logic to looping.      --##
#-- ARK: 29-Jun-09 06:00 to 07:00 (1.0 hrs) Modified catch gear plot.        --##
#-- JSC: 20-Jul-09 (many hrs) Added MCMC and MLE available harvest functions --##
#-- JSC: retro plot#
#																			   ##
#                                                                              ##
# NOTES:                                                                       ##
#                                                                              ##
# 1. To display hidden functions, e.g., .foo, enter command: ls(all.names=TRUE)##
# 2. Unique file names can be created by command:                              ##
#                                                                              ##
#    paste( "sim", format( Sys.time(), format="%d%m%Y%H%M%S" ), sep="" )       ##
#                                                                              ##
# 3. Any information read from a text box has a linefeed \n the end of the     ##
#    input that needs to be removed, in most cases, before use.                ##
# 4. Very inelegant crashes can occur if the browser is called when GUI open.  ##
#    This is a PBSmodelling/TkTcl issue and not something we can fix.          ##
# 5. PBSModelling has the very undesirable of changing character vectors to    ##
#    factor variables within the GUI parameter list.  Not good.  Watch out.    ##
#                                                                              ##
# REQUIRES: PBSmodelling, RODBC                                                ##
#                                                                              ##
# References:                                                                  ##
#                                                                              ##
# Schnute, J.T., Couture-Beil, A., Haigh, R., and Egeli, A. 2008. PBS          ##
#   Modelling 2.00: userís guide revised from Canadian Technical Report of     ##
#   Fisheries and Aquatic Science 2674: v+146 p. Last updated October 23, 2008 ##
#                                                                              ##
# GUI Functions:                                                               ##
#                                                                              ##
#   Flow: guiView -> .hcamViewSetup -> .wkDirSetup -> createWin -> .subView    ##
#                                                                              ##
# guiView        : Run the HCAM viewer GUI.                                    ##
#                                                                              ##
# GUI Error Checking/Validation:                                               ##
#                                                                              ##
# .validViewPars : Check if the GUI parameters are valid.                      ##
#                                                                              ##
# GUI Submit Control Functions:                                                ##
#                                                                              ##
# .subView       : Processes guiMyGui submit actions, e.g., buttons.           ##
#                                                                              ##
# GUI Plot Functions:                                                          ##
#                                                                              ##
# ARK: Jac needs to provide a list of plot functions and short descriptor here.##
#                                                                              ##
# GUI Helper Functions:                                                        ##
#                                                                              ##
# GUI Hidden Functions (to show hidden function ls(all.names=TRUE)):           ##
#                                                                              ##
# .excelTable    : Creates and saves a dataframe to Microsoft Excel table      ##
# .getWinName    : Get the current GUI window name.                            ##
# .hcamViewSetup : Set up and run the specified GUI.                           ##
# .viewFile      : View a file saved in the mseRtemp directory.                ##
# .viewHdrStatus : Updates the status of the header table in guiView (NA).     ##
# .viewHelp      : View a file saved in the mseRhelp directory.                ##
# .wkDirSetup    : Working directory set-up.                                   ##
#------------------------------------------------------------------------------##
#
# General global variables.#
.PACKAGE <- "hcam"#
#
# Following directory names usually prefixed by .PACKAGE so that, for example,#
# the directory name for .FDOCS becomes "mseRdocs".#
.FDOCS    <- "docs"              # Directory containing documents.#
.FHELP    <- "help"              # Directory containing help files.#
.FSTAT    <- "hcamViewStats.xls" # Statistics and results file (Excel .xls).#
.FTEMP    <- "temp"              # Directory containing temporary files.#
#
# Tracking file.#
.VIEWTRCK <- "hcamViewTracker.txt"   # File that holds the tracking information.#
#
# Graphics defaults.#
.VIEWCEX    <- 1            # Generic default cex for axis labels etc.#
.VIEWPANCEX <- 1            # Default cex for panLab.#
#
.VIEWMAR  <- c(2, 2, 1, 1)  # Multi-panel plots: plot margin sizes c(b,l,t,r).#
.VIEWOMA  <- c(2, 2, 1, 1)  # Multi-panel plots: outer margin sizes c(b,l,t,r).#
.VIEWYLAS <- 2#
#
# ARK: Here is where Jac should define defaults for variable types, e.g.:#
# .PLTSSBCOL <- "black"#
# .PLTSSBLTY <- 1#
# .PLTSSBLWD <- 1#
# This allows consistent use of colours, line types and widths, etc.#
#
#-----------------------------------------------------------------------------###
#-- GUI Functions                                                           --###
#-----------------------------------------------------------------------------###
#
# guiView     (Run GUI)#
# Purpose:    Run the GUI.#
# Parameters: None#
# Returns:    NULL (invisibly)#
guiView <- function()#
{#
  return( .hcamViewSetup("hcamView"))#
}#
#
#------------------------------------------------------------------------------##
#-- Gui Error Checking                                                       --##
#------------------------------------------------------------------------------##
#
# .validViewPars (valid parameters for myGUI):#
# Purpose:      Check whether the parameters supplied are valid.#
#               If invalid, display an error message in the R console and#
#               clear the invalid field.#
#               If it is a correctable field, corrects it in the GUI and does#
#               not flag it as invalid.#
# Parameters:   None#
# GUI inputs:   Parameters taken directly from active hCamView. #
# Returns:      TRUE if the parameters were valid, FALSE otherwise.#
# GUI outputs:  Clears invalid fields, corrects correctable fields (if any)#
.validViewPars <- function()#
{#
  # Get the GUI  values and make them local to this function.#
  getWinVal( scope="L" )#
                    #
  isValid <- TRUE#
  #
  # This will be a list of the parameters that require changing.                                                     #
  changes <- list()#
  #
  # The algorithm is to evalute the validity of each GUI parameter.#
  # If a change is required then:#
  # (i)   Make the change;#
  # (ii)  Assign any Global parameters to the parent frame.#
  # (iii) Set isValid to FALSE if a change cannot be made.#
#
  # Example for GUI parameter "x".  #
  # if ( is.na(x) || (x <= 1) || (x > 10) )#
  # {#
  #   cat( "Parameter x must be 1 <= x <= 10".\n" )#
  #   changes$x <- NA#
  #   isValid <- FALSE#
  # }#
  #
  # Check that the number of columns in a multipanel plot is positive.#
  if ( is.na(ncols) || (ncols < 1) )#
  {#
    cat( "(.validViewPars): Number of columns must be positive.\n" )#
    changes$ncols <- NA#
    isValid <- FALSE    #
  }#
  #
  # Check that the number of rows in a multipanel plot is positive.#
  if ( is.na(nrows) || (nrows < 1) )#
  {#
    cat( "(.validViewPars): Number of rows must be positive.\n" )#
    changes$nrows <- NA#
    isValid <- FALSE    #
  }#
  #
  # ARK: Jac needs to add bounds checking for remaining GUI parameters such#
  #      as those specifying the x and y axis limits.#
#
  # If there are invalid parameters, bring the console to the top.  #
  if ( !isValid )#
    bringToTop( -1 )#
  #
  # This takes the accumulated list of changes and applies them to the GUI.#
  setWinVal( changes )#
  return( isValid )#
}#
#
#-----------------------------------------------------------------------------###
#-- GUI Submit Functions                                                    --###
#-----------------------------------------------------------------------------###
#
# .subView   (Processes guiMyGui submit actions, e.g., buttons)#
# Purpose:    This is the function that directs the guiMyGui program flow:#
#             - Attempts to check validity of the GUI parameters;#
#             - processes any button actions;#
#             - processes any radio button actions;#
#             - process any file open/save actions;#
#             - processes any entry field actions.#
# Parameters: NONE#
# Returns:    NULL (invisibly)#
##
# Notes:      Any information read from a text box has a \n at the end of the #
#             input that needs to be removed, in most cases, before use.#
# Source:     A.R. Kronlund#
.subView <- function()#
{#
  win     <- .getWinName()                       # Get the current window name#
  gvar    <- paste( ".", win, sep="" )           # Global variable name#
  #
  valid   <- TRUE#
  valid   <- .validViewPars()                    # Are View parameters valid?  #
  guiInfo <- getWinVal( scope="L", winName=win ) # GUI information local scope#
  act     <- getWinAct()[1]                      # Get last menu window action#
  #
  guiList <- guiInfo                             # Make a copy for changes.#
#
  changes <- list()#
  #
  if ( selectall )#
  {#
    if ( act!="hcamHeader" )#
    {#
      # If nothing in the header was touched, then all runs selected.#
      hcamHeader$Select <- rep( TRUE,nrow(hcamHeader) )#
      changes$hcamHeader <- hcamHeader#
    }#
    else#
    {#
      # One of the runs was unchecked, so selectall turned off.#
      selectall <- FALSE#
      changes$selectall <- FALSE#
      #
    }#
  }#
  else#
  {#
    # Now check to ensure that AT LEAST one run is selected.#
    # If not, then select the first run.#
    if ( sum(hcamHeader$Select)==0 )#
    {#
      hcamHeader$Select[1] <- TRUE#
      changes$hcamHeader <- hcamHeader#
      cat( "\nMSG (.subView): At least one model run MUST be selected, resetting.\n" )#
    }#
  }#
  setWinVal( changes )#
#
  if ( valid )#
  {#
    # Process any GUI actions.#
    #
    # CLEAR the graphics windows.#
    if ( act=="clrgfx" )#
    {#
      graphics.off()#
    }#
    #
    # EXIT the View GUI (leave graphics on).#
    if ( act=="exit" )#
    {#
      closeWin()#
    }#
  #
    # TABLES button.#
    if ( act=="tables" )#
    {#
      cat( "MSG (.subView): Calculating statistics...\n" )#
      # 1. If default results exist, then query overwrite or new name, else go.#
      tmpFile <- .FSTAT#
      #if ( file.exists( .FSTAT ) )#
      tmpFile <- promptSaveFile( initialfile=.FSTAT,#
                   filetype=list( c(".xls","Excel files") ) )#
                     #
      # If the user selectec "Cancel", then tmpFile is an empty string "".#
                     #
      # 2. Call statistics (calcStats).#
      #
      # "Cancel" was not selected at promptSaveFile.#
      if ( tmpFile!="" )#
      {#
        # a. Tracking file.#
        trackTable <- read.table( .VIEWTRCK, as.is=TRUE, header=TRUE, sep=",", skip=1 )#
      #
        # b. guiView parameters - everything but the tracking table. Remember#
        #    to transpose it so it appears as a column in the Excel sheet.#
        guiViewTable <- getWinVal()#
        guiViewTable <- t( guiViewTable[ names(guiViewTable)!="hcamHeader" ] )#
#
        # c. Statistics.      #
        availHarvestMLE <- calcAvailHarvestMLE( hcamHeader ) #
        availHarvestMCMC <- calcAvailHarvestMCMC( hcamHeader ) #
		#
        # Save to Excel.#
        saveToExcel( tmpFile, list(#
                     trackTable=trackTable,#
                     guiViewTable=guiViewTable,#
                     availHarvestMLE=availHarvestMLE,#
                     availHarvestMCMC=availHarvestMCMC )#
                   )#
      #
        # Open Excel file.#
        openFile( tmpFile )#
      }      #
    }#
    #
    # TRACKER button.#
    #if ( act=="tracker" )#
    #{#
    #  cat( "\nTracker button was pressed...\n" )#
    #  tmpFile <- .VIEWTRCK#
    #  #if ( file.exists( .FSTAT ) )#
    #  tmpFile <- promptOpenFile( initialfile=.VIEWTRCK,#
    #               filetype=list( c(".txt","Text files") ) )#
    #               #
    #  # "Cancel" was not selected at promptSaveFile.#
    #  if ( tmpFile!="" )#
    #    .VIEWTRCK <- tmpFile#
    #}#
  #
    # Save the View GUI parameters to a global in the working environment.#
    if ( !act=="exit" )#
    {#
      assign( "guiViewList",guiList,pos=1 )#
      .doViewPlots()#
    }#
  }     # if valid.#
  else#
  {#
    # Invalid GUI parameters so bring R console to top.#
    bringToTop(-1)#
    #
    # EXIT the Simulation GUI (leave graphics on).#
    if ( act=="exit" )#
    {#
      closeWin()#
    }#
  }     # invalid.#
  #
  return( invisible() )  #
}#
#
#------------------------------------------------------------------------------##
#-- Plotting Functions                                                       --##
#------------------------------------------------------------------------------##
#
# .doViewPlots  (Manages plotting funcitons for hCamViewer)#
# Purpose:      Detemines graphics windows layout and loops through currently#
#               selected model runs, plotting the requested graph.#
# Parameters:   None.#
# Returns:      NULL (invisibly)#
# Side Effects: Produces a plot.#
# Source:       A.R. Kronlund#
.doViewPlots <- function()#
{#
  # Get the guiPerf parameters so that plot controls available.#
  guiInfo <- getWinVal(scope="L")#
  #
  # Start a list of guiChanges.#
  guiChanges <- list()#
  #
  # Determine which model runs have been selected.#
  hdr <- hcamHeader[ hcamHeader$Select, ]#
  #
  iRow <- 0#
  nRuns <- nrow( hdr )#
  #
  if ( plotType=="traces" | plotType=="density" | plotType=="pairs" )#
    mcmcPlots <- TRUE#
  else#
    mcmcPlots <- FALSE#
  #
  # Set windows pars here.#
  if ( autolayout )#
  {#
    # Non-mcmc plots.#
    #
    if ( nRuns < 4 )#
    {#
      winCols <- 1#
      winRows <- nRuns#
    }#
    else if ( (nRuns>3) && (nRuns<=6) )#
    {#
      winCols <- 2#
      winRows <- 3#
    }#
    #
    # Combo plots -where each Run has more than one plot panel.#
    # For example, .plotSpBioIdxRes creates two plots per Run.#
    if ( plotType=="catchgear" || plotType=="predcatch" )#
    {#
      winCols <- nRuns#
      winRows <- 3#
    }#
#
    if ( plotType=="spBioIdxRes" )#
    {#
      winCols <- nRuns#
      winRows <- 2#
    }#
    #
    # MCMC plots.#
    if ( mcmcPlots )#
    {#
      winCols <- 3#
      winRows <- 3#
    }#
  }#
  else#
  {#
    winCols <- ncols#
    winRows <- nrows#
  }#
    #
  # Update the GUI parameters.#
  guiChanges$ncols <- winCols#
  guiChanges$nrows <- winRows#
  setWinVal( guiChanges )#
  #
  if ( plotbyrow )#
    par( oma=.VIEWOMA, mar=.VIEWMAR, mfrow=c(winRows,winCols) )#
  else#
    par( oma=.VIEWOMA, mar=.VIEWMAR, mfcol=c(winRows,winCols) )#
  #
  # Loop over the selected run results.#
  newPlot <- FALSE#
  for ( i in 1:nRuns )#
  {#
    # Remove whitespace from field read from GUI text box.#
    fileName <- gsub( " ", "", hdr$RepFile[i] )#
     #
    # Load an HCAM rep file.#
    cat( "\nMSG (.doViewPlots) Loading",fileName,"...\n" )     #
    repObj <- lisread( fname=fileName, quiet=TRUE )#
    #
    # Load an HCAM mcmc file, apparently these are tab delimited.#
    if ( hdr$mcmcFile[i]!="NA" )#
    {#
      mcmcName <- gsub( " ", "", hdr$mcmcFile[i] )    #
      if ( file.exists( mcmcName ) )#
      {#
        cat( "\nMSG (.doViewPlots) Loading",mcmcName,"...\n" )    #
        mcmcObj <- read.table( file=mcmcName, as.is=TRUE, header=TRUE, sep="\t" )#
      }#
      else#
        cat( "\nMSG (.doViewPlots ) Warning",mcmcName," not found...\n" )#
    }#
    else#
      mcmcObj <- NULL#
   #
    # GUI set to output a new graphics window for each run, and new plot required.#
    if ( !overwrite && newPlot )#
    {#
      windows()#
      if ( plotbyrow )#
        par( oma=.VIEWOMA, mar=.VIEWMAR, mfrow=c(winRows,winCols) )#
      else#
        par( oma=.VIEWOMA, mar=.VIEWMAR, mfcol=c(winRows,winCols) )#
      newPlot <- FALSE#
    }#
    #
    if ( overwrite && newPlot )#
    {#
      if ( plotbyrow )#
        par( oma=.VIEWOMA, mar=.VIEWMAR, mfrow=c(winRows,winCols) )#
      else#
        par( oma=.VIEWOMA, mar=.VIEWMAR, mfcol=c(winRows,winCols) )#
      newPlot <- FALSE    #
    }    #
#
    # ARK: This is where Jac will add new plots, following the structure of #
    #      .plotBiomass, .plotCatch, and .plotM.#
    #
    # ARK: Jac WILL add the plots in alphabetical order so that humans can find#
    #      them in the "if" block. She WILL also use descriptive function names#
    #      like .plotAvail rather than .plotA... but things like .plotF and#
    #      .plotM are OK.#
    #
    # (a) Add an "if" block where plotType is defined in hcamViewWin.txt.#
    # (b) Add a plot function as per .plotBiomass, etc.#
    # (c) Test it.#
    #
    if ( plotType=="ageresids" )#
    {#
      .plotAgeResids( repObj, label= hdr$Stock[i], annotate, fixXaxis, fixYaxis )#
    }#
    #
    if ( plotType=="availability" )#
    {#
	  .plotA( repObj, label=paste( hdr$Stock[i] ), annotate, fixXaxis, fixYaxis )#
    }#
    #
    if ( plotType=="biomass" )#
    {#
      .plotBiomass( repObj, label= hdr$Stock[i], annotate, fixXaxis, fixYaxis )#
    }#
    #
    if ( plotType=="catch" )#
    {#
      .plotCatch( repObj, label= hdr$Stock[i], annotate, fixXaxis, fixYaxis )#
    }#
    #
    if ( plotType=="catchgear" )#
    {#
      .plotCatchGear( repObj, label= hdr$Stock[i], annotate, fixXaxis, fixYaxis )#
    }#
    #
    if ( plotType=="cutoffs" )#
    {#
      .plotCutoffs( repObj, label=paste( hdr$Stock[i], hdr$Run[i] ), annotate, fixXaxis, fixYaxis )#
    }#
    #
    if ( plotType=="fishmort" )#
    {#
      .plotF( repObj, label=hdr$Stock[i], annotate, fixXaxis, fixYaxis )#
    }#
    #
    if ( plotType=="forecast" )#
    {#
      .plotForecast( repObj, label= hdr$Stock[i], annotate, fixXaxis, fixYaxis )#
    }#
    #
    if ( plotType=="mortality" )#
    {#
      .plotMandF( repObj, label= hdr$Stock[i], annotate, fixXaxis, fixYaxis )#
    }#
#
    if ( plotType=="natmort" )#
    {#
      .plotM( repObj, label= hdr$Stock[i], annotate, fixXaxis, fixYaxis )#
    }#
#
    if ( plotType=="natmortage" )#
    {#
      .plotMage( repObj, label= hdr$Stock[i], annotate, fixXaxis, fixYaxis )#
    }#
#
    if ( plotType=="obspredcatch" )#
    {#
      .plotObsPredCt( repObj, label= hdr$Stock[i], annotate, fixXaxis, fixYaxis )#
    }   #
      #
    if ( plotType=="propagebubble" )#
    {#
      .plotObsPropAge( repObj, label= hdr$Stock[i], annotate, fixXaxis, fixYaxis )#
    }#
    #
    if ( plotType=="recruits" )#
    {#
      .plotRecruits( repObj, label= hdr$Stock[i], annotate, fixXaxis, fixYaxis )#
    }#
    #
    if ( plotType=="retrospective" )#
    {#
      .plotRetroPrefishB ( hdr=hdr[i,], label= hdr$Stock[i], annotate, fixXaxis, fixYaxis )#
    }#
    #
    if ( plotType=="selectivity" )#
    {#
      .plotS( repObj, label= hdr$Stock[i], annotate, fixXaxis, fixYaxis )#
    }#
    #
    if ( plotType=="spawn" )#
    {#
      .plotSpawn( repObj, label= hdr$Stock[i], annotate, fixXaxis, fixYaxis )#
    }#
    #
    if ( plotType=="spBioIdxRes" )#
    {#
      .plotSpBioIdxRes( repObj, label= hdr$Stock[i], annotate, fixXaxis, fixYaxis )#
    }#
    #
    if ( plotType=="weight" )#
    {#
      .plotWeightAgeXbyYear( repObj, label= hdr$Stock[i], annotate, fixXaxis, fixYaxis )#
    }#
    #
    if ( plotType=="wtage" )#
    {#
      .plotWtAge( repObj, label= hdr$Stock[i], annotate, fixXaxis, fixYaxis )#
    }#
    #
    # MCMC Plots#
    if ( !is.null(mcmcObj) )#
    {#
      if ( plotType=="density" )#
      {#
        .mcmcDensity( mcmcObj, label= hdr$Stock[i], annotate )#
      }#
      #
      if ( plotType=="pairs" )#
      {#
        .mcmcPairs( mcmcObj, label= hdr$Stock[i], annotate )#
      }#
      #
      if ( plotType=="traces" )#
      {#
        .mcmcTraces( mcmcObj, label= hdr$Stock[i], annotate )#
      }#
    }#
    #
    # This sets newPlot to TRUE if current plot panel is the last row and#
    # last column of the layout.#
    mfg <- par( "mfg" )#
    if ( (mfg[1]==mfg[3]) && (mfg[2]==mfg[4]) )#
      newPlot <- TRUE#
    #
    if ( mcmcPlots )#
      newPlot <- TRUE#
      #
    if ( newPlot || i==nRuns )#
    {#
      if ( saveemf )#
        savePlot( filename=paste( "fig",hdr$Stock[i],plotType,sep="" ),#
          type="emf", restoreConsole = TRUE ) #
    }#
    #
  }   # Loop over i run results.  #
                        #
  return( invisible() )#
}#
#
#
.plotBiomass <- function( repObj, label=NULL, annotate=TRUE,#
                          fixXaxis=FALSE, fixYaxis=FALSE )#
{#
  years    <- c( repObj$syr:repObj$nyr )#
  Bprefish <- repObj$Bprefish / 1000.0   # Prefishery spawning biomass (t).#
  #estSB    <- repObj$estSB / 1000.0	#25Aug2010#
  predSB   <- repObj$predSB / 1000.0		# q*estSB#
  obsSB    <- repObj$obsSB    / 1000.0#
#
  xRange <- range( years )#
  if ( fixXaxis )#
  {#
    guiList <- getWinVal( scope="L" )#
    xRange[1] <- xMinYr#
    xRange[2] <- xMaxYr#
  }#
#
#   yRange <- range( c(Bprefish,estSB,obsSB ), na.rm=TRUE ) #25Aug2010#
  yRange <- range( c(Bprefish,predSB,obsSB ), na.rm=TRUE ) #25Aug2010#
  #
  if ( fixYaxis )#
  {#
    guiList <- getWinVal( scope="L" )#
    yRange[1] <- yMinBio#
    yRange[2] <- yMaxBio#
  }#
#
  plot( xRange, yRange, type="n", axes=FALSE, xlab="",ylab="" )#
  #
  lines( years, Bprefish, col="black" )#
#   lines( years, estSB,    col="black", lty=5 ) #25Aug10#
  lines( years, predSB,   col="black", lty=5 )	 #25Aug10#
  lines( years, obsSB,    col="black", lty=2 )#
  points( years, obsSB,   col="black", pch=16 )#
    #
  axis( side=1 )#
  axis( side=2, las=.VIEWYLAS )#
  box()#
  #
  panLab( 0.05,0.95, adj=0, cex=1.25, label )#
#   mtext( side=1, line=0.5, cex=.VIEWCEX, outer=TRUE, "Year" )#
  mtext( side=2, line=0.5, cex=.VIEWCEX, outer=TRUE, "Biomass (x 1,000 tonnes)" )#
#
  if ( annotate )#
  {#
    mfg <- par( "mfg" )#
    if ( mfg[1]==1 && mfg[2]==1 )#
      legend( "top",legend=c( "Pre-fishery biomass","Spawning biomass",#
              "Spawn index" ),#
              bty='n',lty=c(1,5,2),lwd=c(1,1,1),pch=c(-1,-1,16),ncol=1 )#
  }#
}#
#
#
.plotObsPredCt <- function( repObj, label=NULL, annotate=TRUE,#
                          fixXaxis=FALSE, fixYaxis=FALSE )#
{#
  years   <- c( repObj$syr:repObj$nyr )#
  #
  obsP1   <- cbind( repObj$obsCtP1[1:length(years)] ) ##Jac FIX this output in ADMB!!#
  obsP2   <- cbind( repObj$obsCtP2[(length(years)+1):(length(years)+1+length(years)-1)] )#
  obsP3   <- cbind( repObj$obsCtP3[(length(years)+1+length(years)):length(repObj$obsCtP3)] )#
#
  predP1  <- repObj$predCtP1 #
  predP2  <- repObj$predCtP2#
  predP3  <- repObj$predCtP3#
  #
  obsCatchByPeriod  <- cbind( obsP1, obsP2, obsP3 )#
  predCatchByPeriod <- cbind( predP1, predP2, predP3 )#
  #
  # Convert catch to 1,000 t.#
  obsCatchByPeriod   <- obsCatchByPeriod/ 1000.0#
  predCatchByPeriod  <- predCatchByPeriod/ 1000.0#
  #
  dimnames( obsCatchByPeriod ) <- list( years, c("Period 1","Period 2","Period 3") )#
                                     #
  xRange <- range( years )   #
  if ( fixXaxis )#
  {#
    guiList <- getWinVal( scope="L" )#
    xRange[1] <- xMinYr#
    xRange[2] <- xMaxYr#
  }#
  #
  yRange <- range( c(obsP1,obsP2,obsP3,predP1,predP2,predP3), na.rm=TRUE )  #
  if ( fixYaxis )#
  {#
    guiList <- getWinVal( scope="L" )#
    yRange[1] <- yMinCat#
    yRange[2] <- yMaxCat#
  }#
#
  for ( j in 1:ncol(obsCatchByPeriod) )#
  {#
    plot( xRange, yRange, axes=FALSE, type="n", xlab="", ylab="" )#
    idx <- obsCatchByPeriod[,j] > 0.0#
	#
    lines(  years[idx], predCatchByPeriod[idx,j], col="black", lty=1 )#
    points( years[idx], obsCatchByPeriod[idx,j],  col="black", pch=16 )#
    #
    axis( side=2, las=.VIEWYLAS )#
    axis( side=3, labels=FALSE )#
    if ( j==ncol(obsCatchByPeriod) )#
      axis( side=1 )#
    else#
      axis( side=1, labels=FALSE )#
    box()#
    panLab( 0.5, 0.9, cex=.VIEWPANCEX, paste( label,"-",j,sep="") )#
  }#
     #
#   mtext( side=1, line=0.5, outer=T, "Year" )#
  mtext( side=2, line=0.5, outer=T, "Total catch (x 1,000 tonnes)" )#
  #
  if ( annotate )#
  {#
    mfg <- par( "mfg" )#
    if ( mfg[1]==1 && mfg[2]==1 )#
      legend( "topright",legend=c( "Pred. catch","Obs. catch" ),#
        bty='n',lty=c(1,2),lwd=c(1,1), pch=c(-1,16),ncol=1 )#
  }#
}#
#
#
.plotCutoffs <- function( repObj, label=NULL, annotate=TRUE,#
                          fixXaxis=FALSE, fixYaxis=FALSE )#
{#
  estB0    <- repObj$Bo     / 1000.0#
  cutOff   <- repObj$cutoff / 1000.0#
#
  xRange <- range( c(0,estB0) )#
  if ( fixXaxis )#
  {#
    guiList <- getWinVal( scope="L" )#
    xRange[1] <- yMinSSB#
    xRange[2] <- yMaxSSB#
  }#
#
  yRange <- range( repObj$availableHarvest, na.rm=TRUE )#
  if ( fixYaxis )#
  {#
    guiList <- getWinVal( scope="L" )#
    yRange[1] <- yMinCat#
    yRange[2] <- yMaxCat#
  }#
#
  plot( xRange, yRange, type="n", axes=FALSE, xlab="",ylab="" )#
  #
  abline( h=repObj$availableHarvest, col=c("red","green","blue"), lty=1 )#
  abline( v=cutOff, col="black", lty=1 )#
    #
  axis( side=1 )#
  axis( side=2, las=.VIEWYLAS )#
  box()#
  #
  panLab( 0.05,0.95, adj=0, cex=1.25, label )#
  mtext( side=1, line=0.5, cex=.VIEWCEX, outer=TRUE, "SSB (1,000 t)" )#
  mtext( side=2, line=0.5, cex=.VIEWCEX, outer=TRUE, "Harvest (t)" )#
#
  if ( annotate )#
  {#
    legend( "topright", legend=c("Poor","Average","Good"),#
            bty="n", col=c("red","green","blue"), lty=1 )#
  }#
}#
#
#obs/pred spawn + residuals#
.plotSpBioIdxRes <- function( repObj, label=NULL, annotate=TRUE,#
                              fixXaxis=FALSE, fixYaxis=FALSE )#
{#
  .plotSpBioIdx( repObj, label=NULL, annotate, fixXaxis, fixYaxis )#
  #
  mfg <- par( "mfg" )#
  #
  if ( mfg[1]==1 && mfg[2]==1 )#
    mtext( side=2, line=2.5, cex=.VIEWCEX, outer=FALSE, "Biomass (x 1,000 tonnes)" )#
  panLab( 0.05,0.95, adj=0, cex=1.25, label )  #
  #
  .plotResids( repObj, label=NULL, annotate, fixXaxis, fixYaxis )#
   abline( v=1988,lty=2 )#
 #
#   mtext( side=1, line=0.5, cex=.VIEWCEX, outer=TRUE, "Year" )#
  #
  mfg <- par( "mfg" )#
  if ( mfg[1]==2 && mfg[2]==1 )#
    mtext( side=2, line=2.5, cex=.VIEWCEX, outer=FALSE, "Residuals (log obs - log pred)" )#
}#
#
  #
.plotSpBioIdx <- function( repObj, label=NULL, annotate=TRUE, fixXaxis=FALSE, fixYaxis=FALSE )#
{#
  years    <- c( repObj$syr:repObj$nyr )#
  #estSB    <- repObj$estSB / 1000.0	#10Jun2010#
  predSB   <- repObj$predSB / 1000.0		# q*estSB#
  obsSB    <- repObj$obsSB / 1000.0#
  #
  xRange <- range( years )#
  if ( fixXaxis )#
  {#
    guiList <- getWinVal( scope="L" )#
    xRange[1] <- xMinYr#
    xRange[2] <- xMaxYr#
  }#
#
#   yRange <- range( c(estSB,obsSB ), na.rm=TRUE )#
  yRange <- range( c(predSB,obsSB ), na.rm=TRUE )#
  if ( fixYaxis )#
  {#
    guiList <- getWinVal( scope="L" )#
    yRange[1] <- yMinBio#
    yRange[2] <- yMaxBio#
  }#
#
  plot( xRange, yRange, type="n", axes=FALSE, xlab="",ylab="" )#
      #
#   lines( years, estSB,  col="black", lty=1 )#
  lines( years, predSB,  col="black", lty=1 )#
  lines( years, obsSB,  col="black", lty=2 )#
  points( years, obsSB, col="black", pch=16 )#
    #
  axis( side=1 )#
  axis( side=2, las=.VIEWYLAS )#
  axis( side=3, label=FALSE )#
  box()#
#
  if ( annotate )#
  {#
    mfg <- par( "mfg" )#
    if ( mfg[1]==1 && mfg[2]==1 )#
      legend( "topright",legend=c( "Est. SSB","Spawn index" ),#
        bty='n',lty=c(1,2),lwd=c(1,1), pch=c(-1,16),ncol=1 )#
  }#
}#
#
.plotResids <- function( repObj, label=NULL, annotate=TRUE, fixXaxis=FALSE, fixYaxis=FALSE )#
{#
  years    <- c( repObj$syr:repObj$nyr )#
  logResid <- repObj$spResid#
#   logResid <- log(repObj$obsSB)-log(repObj$estSB) # same as repObj$spResid (still incorrect)#
#
  xRange <- range( years )#
  if ( fixXaxis )#
  {#
    guiList <- getWinVal( scope="L" )#
    xRange[1] <- xMinYr#
    xRange[2] <- xMaxYr#
  }#
#
  yRange <- range( logResid, na.rm=TRUE )#
  if ( fixYaxis )#
  {#
    guiList <- getWinVal( scope="L" )#
    yRange[1] <- yMinResid#
    yRange[2] <- yMaxResid#
  }#
  plot( xRange, yRange, type="n", axes=FALSE, xlab="",ylab="" )#
  for ( i in 1:length(years) )#
  {#
	  lines( c(years[i],years[i]),c(0,logResid[i]),lty=1 )#
	}#
  axis( side=1 )#
  axis( side=2, las=.VIEWYLAS )#
  axis( side=3, label=FALSE )#
  box()	  #
}#
#
#
#Jac plot4- spawn index#
.plotSpawn <- function( repObj, label=NULL, annotate=TRUE,#
                          fixXaxis=FALSE, fixYaxis=FALSE )#
{#
  years    <- c( repObj$syr:repObj$nyr )#
  obsSB    <- repObj$obsSB    / 1000.0	 # Observed spawning biomass (t).#
#
  xRange <- range( years )#
  if ( fixXaxis )#
  {#
    guiList <- getWinVal( scope="L" )#
    xRange[1] <- xMinYr#
    xRange[2] <- xMaxYr#
  }#
#
  yRange <- range( obsSB )#
  if ( fixYaxis )#
  {#
    guiList <- getWinVal( scope="L" )#
    yRange[1] <- yMinBio#
    yRange[2] <- yMaxBio#
  }#
#
  plot( xRange, yRange, type="n", axes=FALSE, xlab="",ylab="" )#
  #
  lines( years, obsSB,  col="black", lty=2 )#
  points( years, obsSB, col="black", pch=16 )#
  #
  axis( side=1 )#
  axis( side=2, las=.VIEWYLAS )#
  box()#
  #
  panLab( 0.05,0.95, adj=0, cex=1.25, label )#
#   mtext( side=1, line=0.5, cex=.VIEWCEX, outer=TRUE, "Year" )#
  mtext( side=2, line=0.5, cex=.VIEWCEX, outer=TRUE, "Biomass (x 1,000 tonnes)" )#
#
}#
#
#
.plotWeightAgeXbyYear <- function( repObj, label=NULL, annotate=TRUE,#
                          fixXaxis=FALSE, fixYaxis=FALSE )#
{#
  years    <- repObj$syr:repObj$nyr#
  obsWtAge <- repObj$obsWtAge				# row=years, col=ages 2:10#
  ages     <- ncol( repObj$obsWtAge )#
  #
  xRange <- range( years )#
  if ( fixXaxis )#
  {#
    guiList <- getWinVal( scope="L" )#
    xRange[1] <- xMinYr#
    xRange[2] <- xMaxYr#
  }#
#
  yRange <- range( repObj$obsWtAge )#
  if ( fixYaxis )#
  {#
    guiList <- getWinVal( scope="L" )#
    yRange[1] <- yMinWt#
    yRange[2] <- yMaxWt#
  }#
#
  plot( xRange, yRange, type="n", axes=FALSE, xlab="",ylab="" )#
  #
  minAge <- 2#
  maxAge <- 6#
#   Col    <- c(#
  for( i in minAge:maxAge )#
  {#
    lines( years, obsWtAge[,i], lty=1 )#
    points( years, obsWtAge[,i], col="black", pch=21, bg=i, cex=1, lwd=1 )#
  }#
#
  # ARK: Replaced legend call.#
  if ( annotate )#
  {#
    #legend( min(years)-10,obsWtAge[1,i],legend=i,bty='n', text.col=i )#
    #legend( max(years),obsWtAge[1,i],legend=i,bty='n', text.col=i )#
    ageNames <- paste( "Age",c(minAge:maxAge) )#
    legend( "topright", legend=ageNames, bty="n", col="black",#
            pch=21, pt.bg=c(minAge:maxAge), lty=1 )#
  }#
#
  axis( side=1 )#
  axis( side=2, las=.VIEWYLAS )#
  box()#
  #
  panLab( 0.05,0.95, adj=0, cex=1.25, label )#
  #mtext( side=1, line=0.5, cex=.VIEWCEX, outer=TRUE, "Year" )#
  mtext( side=2, line=0.5, cex=.VIEWCEX, outer=TRUE, "Weight (g)" )#
#
}#
  #
#
# ARK: Jac - probably should include year as the first column in the obsWtAge#
#      output in the rep file. Pretty dangerous not to have the year index associated#
#      with the matrix in the rep file.#
#
.plotWtAge <- function( repObj, label=NULL, annotate=TRUE,#
                          fixXaxis=FALSE, fixYaxis=FALSE )#
{#
  ages     <- repObj$minAge:repObj$maxAge#
  obsWtAge <- repObj$obsWtAge				# row=years, col=ages 2:10#
  #
  years <- c(repObj$syr:repObj$nyr)#
#
  #
  # Find every tenth year.#
  idxYear <- as.logical( years %% 20 == 0 )#
  #
  # Now add most recent year.#
  # JSC(25-Aug-10): this may need to be adjusted each yr.#
#   idxYear[ length(idxYear)-1 ] <- TRUE#
   idxYear[ length(idxYear) ] <- TRUE#
#
  xRange <- range( ages )#
  if ( fixXaxis )#
  {#
    guiList <- getWinVal( scope="L" )#
    xRange[1] <- xMinAge#
    xRange[2] <- xMaxAge#
  }#
#
  yRange <- range( repObj$obsWtAge )#
  if ( fixYaxis )#
  {#
    guiList <- getWinVal( scope="L" )#
    yRange[1] <- yMinWt#
    yRange[2] <- yMaxWt#
  }#
#
  plot( xRange, yRange, type="n", axes=FALSE, xlab="",ylab="" )#
  #
  # Add the points that are not highlighted.#
  tmp <- obsWtAge[ !idxYear, ]#
  for ( i in 1:nrow(tmp) )#
  {#
    points( jitter( ages ), tmp[i,], pch=21, bg="white", cex=1 )#
  }#
  #
  # Add the points that are to be highlighted.#
  tmp <- obsWtAge[ idxYear, ]#
  for ( i in 1:nrow(tmp) )#
  {#
    lines( ages, tmp[i,], lty=1 )#
    points( ages, tmp[i,], pch=21, bg=i, cex=1.5 )#
  } #
      #
  axis( side=1 )#
  axis( side=2, las=.VIEWYLAS )#
  box()#
#
  legend( "bottomright", legend=years[idxYear], pch=21, pt.bg=c(1:nrow(tmp)),#
          pt.cex=1.5, lty=1, bty="n" )#
  #
  panLab( 0.05,0.95, adj=0, cex=1.25, label )#
  mtext( side=1, line=0.5, cex=.VIEWCEX, outer=TRUE, "Age" )#
  mtext( side=2, line=0.5, cex=.VIEWCEX, outer=TRUE, "Weight (g)" )#
}#
#
#
#Jac plot5- forecast spawn biomass#
.plotForecast <- function( repObj, label=NULL, annotate=TRUE,#
                          fixXaxis=FALSE, fixYaxis=FALSE )#
{#
  years    <- c( repObj$syr:repObj$nyr )#
  Bprefish <- repObj$Bprefish / 1000.0   # Prefishery spawning biomass (t).#
  #estSB    <- repObj$estSB / 1000.0	#25Aug2010#
  predSB   <- repObj$predSB / 1000.0		# q*estSB  #
  obsSB    <- repObj$obsSB    / 1000.0#
  cutoff   <- repObj$cutoff   / 1000.0 #
#
  xRange <- range( years )#
  if ( fixXaxis )#
  {#
    guiList <- getWinVal( scope="L" )#
    xRange[1] <- xMinYr#
    xRange[2] <- xMaxYr#
  }#
#
#   yRange <- range( c(Bprefish,estSB,obsSB ), na.rm=TRUE ) #25Aug2010#
  yRange <- range( c(Bprefish,predSB,obsSB ), na.rm=TRUE ) #25Aug2010#
  if ( fixYaxis )#
  {#
    guiList <- getWinVal( scope="L" )#
    yRange[1] <- yMinBio#
    yRange[2] <- yMaxBio#
  }#
#
  plot( xRange, yRange, type="n", axes=FALSE, xlab="",ylab="" )#
  #
  lines( years, Bprefish, col="black" )#
#   lines( years, estSB,    col="black", lty=5 ) #25Aug10#
  lines( years, predSB,   col="black", lty=5 )	 #25Aug10  #
  lines( years, obsSB,    col="black", lty=2 )#
  points( years, obsSB,   col="black", pch=16 )#
  #
  # JSC: put in an if statement to only plot cutoff for major stock areas#
  segments( 1996, cutoff, repObj$nyr, cutoff, col="black", lwd=2 )#
  #
  axis( side=1 )#
  axis( side=2, las=.VIEWYLAS )#
  box()#
  #
  panLab( 0.05,0.95, adj=0, cex=1.25, label )#
#   mtext( side=1, line=0.5, cex=.VIEWCEX, outer=TRUE, "Year" )#
  mtext( side=2, line=0.5, cex=.VIEWCEX, outer=TRUE, "Biomass (x 1,000 tonnes)" )#
#
  if ( annotate )#
  {#
    mfg <- par( "mfg" )#
    if ( mfg[1]==1 && mfg[2]==1 )#
    #
  # JSC: put in an if statement to only include cutoff in legend for major stock areas#
      legend( "top",legend=c( "Pre-fishery biomass","Spawning biomass",#
              "Spawn index","Cutoff" ),#
              bty='n',lty=c(1,5,2,1),lwd=c(1,1,1,2), pch=c(-1,-1,16,-1),ncol=1 )#
#       legend( "topright",legend=c( "Pre-fishery biomass","Spawning biomass",#
#               "Spawn index" ),#
#               bty='n',lty=c(1,5,2),lwd=c(1,1,1), pch=c(-1,-1,16),ncol=1 )#
              #
  }#
}#
#
# #Formatted for LR presentation#
# .plotForecast <- function( repObj, label=NULL, annotate=TRUE,#
#                           fixXaxis=FALSE, fixYaxis=FALSE )#
# {#
#   years    <- c( repObj$syr:repObj$nyr )#
#   Bprefish <- repObj$Bprefish / 1000.0   # Prefishery spawning biomass (t).#
#   estSB    <- repObj$estSB    / 1000.0#
#   obsSB    <- repObj$obsSB    / 1000.0#
#   cutoff   <- repObj$cutoff   / 1000.0 #
#
#   xRange <- range( years )#
#   if ( fixXaxis )#
#   {#
#     guiList <- getWinVal( scope="L" )#
#     xRange[1] <- xMinYr#
#     xRange[2] <- xMaxYr#
#   }#
#
#   yRange <- range( c(Bprefish,estSB,obsSB ), na.rm=TRUE )#
#   if ( fixYaxis )#
#   {#
#     guiList <- getWinVal( scope="L" )#
#     yRange[1] <- yMinBio#
#     yRange[2] <- yMaxBio#
#   }#
#
#   plot( xRange, yRange, type="n", axes=FALSE, xlab="",ylab="" )#
#   #
#   lines( years, Bprefish, col="black" )#
#   points( years, Bprefish,   col="black", pch=16 )#
#   #
#   segments( 1985, cutoff, repObj$nyr, cutoff, col="black", lwd=2 )#
#   #
#   axis( side=1 )#
#   axis( side=2, las=.VIEWYLAS )#
#   box()#
#   #
# #   panLab( 0.05,0.95, adj=0, cex=1.25, label )#
# #   mtext( side=1, line=0.5, cex=.VIEWCEX, outer=TRUE, "Year" )#
#   mtext( side=2, line=0.5, cex=.VIEWCEX, outer=TRUE, "Pre-fishery biomass (x 1,000 tonnes)" )#
#
# }#
#
#
#
.plotCatch <- function( repObj, label=NULL, annotate=TRUE,#
                        fixXaxis=FALSE, fixYaxis=FALSE )#
{#
  # Require data	#
  years <- repObj$B[,1]#
  B     <- repObj$B[,3]/ 1000.0#
  #
  # Ensures only those catches > 0.01 are plotted.#
  idx   <- repObj$B[,3] > 0.01#
    #
  # Convert catch to 1,000 t.#
  B <- B#/1000#
  #
  xRange <- range( years )#
  if ( fixXaxis )#
  {#
    guiList <- getWinVal( scope="L" )#
    xRange[1] <- xMinYr#
    xRange[2] <- xMaxYr#
  }#
  #
  yRange <- range( B, na.rm=TRUE )#
  if ( fixYaxis )#
  {#
    guiList <- getWinVal( scope="L" )#
    yRange[1] <- yMinCat#
    yRange[2] <- yMaxCat#
  }#
  #
  plot( xRange, yRange, type="n", xlab="", ylab="", yaxt="n" )#
  lines( years[idx], B[idx], type="h", lwd=3 )#
  axis( 2, las=2 )#
  box()#
  #
#   if( annotate )#
#   {#
#     legend( "top",legend=years[i],bty='n' )#
#     if( years[i] <= 1971 )#
#       legend( "topright",legend="P1",bty='n' )#
#     else#
#       legend( "topright",legend="P2",bty='n' )#
#   }#
  #
  panLab( 0.05,0.90, adj=0, cex=.VIEWPANCEX, label )#
#   mtext( side=1, line=0.5, outer=T, "Year" )#
  mtext( side=2, line=0.5, outer=T, las=0, "Total catch (x 1,000 tonnes)" )#
#
}#
#
#
.plotCatchGear <- function( repObj, label=NULL, annotate=TRUE,#
                        fixXaxis=FALSE, fixYaxis=FALSE )#
{#
  # ARK: Jac, don't write code like this without a few lines of explanation of the#
  # logic - you will regret it in 3 months when you try to revisit it...#
  #
  # ARK: Jac - why is biomass in 10,000 t units and catch in t units?  It gets#
  #      confusing.  For most plotting purposes, I would think everything in#
  #      10,000 t units would be fine.  That avoids large amounts of real estate#
  #      being chewed up in horizontal (yuck) axis labels.#
  #      Tables showing catch could be done in tonnes, if industry is counting tonnes...#
  #
  years     <- repObj$B[,1]#
  #
  period1   <- cbind( repObj$obsCtP1[1:length(years)] ) ##Jac FIX this output in ADMB!!#
  period2   <- cbind( repObj$obsCtP2[(length(years)+1):(length(years)+1+length(years)-1)] )#
  period3   <- cbind( repObj$obsCtP3[(length(years)+1+length(years)):length(repObj$obsCtP3)] )#
  #
  catchByPeriod <- cbind( period1, period2, period3 )#
  #
  # Convert catch to 1,000 t.#
  catchByPeriod <- catchByPeriod/1000.0#
  #
  dimnames( catchByPeriod ) <- list( years, c("Period 1","Period 2","Period 3") )#
                                     #
  xRange <- range( years )   #
  if ( fixXaxis )#
  {#
    guiList <- getWinVal( scope="L" )#
    xRange[1] <- xMinYr#
    xRange[2] <- xMaxYr#
  }#
  #
  yRange <- range( c(period1,period2,period3), na.rm=TRUE )  #
  if ( fixYaxis )#
  {#
    guiList <- getWinVal( scope="L" )#
    yRange[1] <- yMinCat#
    yRange[2] <- yMaxCat#
  }#
#
  for ( j in 1:ncol(catchByPeriod) )#
  {#
    plot( xRange, yRange, axes=FALSE, type="n", xlab="", ylab="" )#
    idx <- catchByPeriod[,j] > 0.0#
    lines( years[idx],catchByPeriod[idx,j],type="h" )#
    axis( side=2, las=.VIEWYLAS )#
    axis( side=3, labels=FALSE )#
    if ( j==ncol(catchByPeriod) )#
      axis( side=1 )#
    else#
      axis( side=1, labels=FALSE )#
    box()#
    panLab( 0.5, 0.9, cex=.VIEWPANCEX, paste( label,"-",j,sep="") )#
  }#
   #
#   mtext( side=1, line=0.5, outer=T, "Year" )#
  mtext( side=2, line=0.5, outer=T, "Total catch (x 1,000 tonnes)" )#
}#
#
.plotRetroPrefishB <- function( hdr, label=NULL, annotate=TRUE,#
                           fixXaxis=FALSE, fixYaxis=FALSE )#
{   #
  # hdr is the index for each option in the tracking file.#
    tmP        <- hdr#
	#
    # Get file prefix from hdr$RepFile#
    x          <- tmP$RepFile#
    dotPos     <- gregexpr(pattern="\\.",x)#
    #
    filePrefix <- x#
    for ( i in 1:length(x) )#
    {#
      xPos <- dotPos[[i]]#
      filePrefix[i] <- substring( x[i],1,xPos-8 )#
      #
	}#
	filePrefix <- paste( filePrefix,"Retro",sep="" )#
	print( filePrefix )  #
    #filePrefix <- paste( substring(x,1,dotPos[[1]]-1),"retro",sep="" )#
#
	# Find all files with filePrefix+retro#
    retroFiles <- list.files( ".", pattern=filePrefix )#
    #
    # Check for rep files only.#
    isRepFile <- gregexpr( pattern="\\.rep",retroFiles )#
    isRepFile <- unlist( isRepFile )#
    isRepFile <- ifelse( isRepFile==-1,FALSE,TRUE )#
    #
   #
    retroFiles <- retroFiles[ isRepFile ]#
    print( retroFiles )#
    #
    # Set up plot and specify number of years using max retro year#
    maxRetro  <- lisread( max(retroFiles), quiet=TRUE )#
    years     <- c( maxRetro$syr:maxRetro$nyr )#
    Bprefish  <- maxRetro$Bprefish/1000.0#
#
    xRange <- range( years )#
    if ( fixXaxis )#
    {#
      guiList <- getWinVal( scope="L" )#
      xRange[1] <- xMinYr#
      xRange[2] <- xMaxYr#
    }#
  #
    yRange <- range( Bprefish ) # hack hack (visual estimate)#
    if ( fixYaxis )#
    {#
      guiList <- getWinVal( scope="L" )#
      yRange[1] <- yMinBio#
      yRange[2] <- yMaxBio#
    }#
  #
    # Set up plot#
    plot( xRange, yRange, type="n", axes=FALSE, xlab="",ylab="" )#
    lines( years, Bprefish, col="black", lwd=2 ) #
    points( maxRetro$nyr, Bprefish[length( Bprefish )], col="black", pch=19 )#
#
    for ( j in 1:length(retroFiles) )#
    {#
      # Define repObj#
      repObj     <- lisread( fname=retroFiles[j], quiet=TRUE )#
  #
      # Specify number of years for retro run i#
      retroYears <- c( repObj$syr:repObj$nyr )  #
#
      # Specify prefishery biomass for retro run i #
      Bprefish   <- repObj$Bprefish/1000.0#
 	#
      # For each retro run i, draw retro line and identify final year with circle#
      lines( retroYears, Bprefish, col="gray", lwd=2 )#
      points( max(retroYears), Bprefish[length( Bprefish )], bg="gray", lwd=2, pch=21 )#
    }#
    #
  # Redraw final year#
  lines( years, Bprefish, col="black", lwd=2 ) #
  points( maxRetro$nyr, Bprefish[length( Bprefish )], col="black", pch=19 )#
#
  axis( side=1 )#
  axis( side=2, las=.VIEWYLAS )#
  box()#
   #
  panLab( 0.05,0.9, adj=0, cex=1.25, label )#
#
#   mtext( side=1, line=0.5, cex=.VIEWCEX, outer=TRUE, "Year" )#
  mtext( side=2, line=0.5, cex=.VIEWCEX, outer=TRUE, "Pre-fishery biomass (x 1,000 tonnes)" )#
}#
#
#
.plotRecruits <- function( repObj, label=NULL, annotate=TRUE,#
                        fixXaxis=FALSE, fixYaxis=FALSE )#
{	#
#   recruits  <- repObj$Nest[1:(length(repObj$syr:repObj$nyr)),] #
#   years     <- repObj$syr:repObj$nyr #
#   Nrecruits <- recruits[,3]/10	# x 1e06#
#   poorAvg   <- quantile( Nrecruits,0.33 )#
#   avgGood   <- quantile( Nrecruits,0.66 )      #
#
  #
  # JSC (11-Sep-09): Revise this figure to correctly MATCH Ron's recruitment forecasts.#
  tmP <- repObj$prefishRecAge3  # year, numbers, biomass#
  # Fix order of data output#
  x <- tmP[,1]#
  y <- tmP[,2]#
  z <- tmP[,3]#
  o <- order( x )#
  recruits <- cbind( x[o], y[o], z[o] )#
  Nrecruits <- recruits[,2]/10 # x 1e06#
  years     <- repObj$syr:repObj$nyr #
  poorAvg   <- quantile( Nrecruits,0.33 )#
  avgGood   <- quantile( Nrecruits,0.66 )      #
#
  #
  xRange <- range( years )#
  if ( fixXaxis )#
  {#
    guiList <- getWinVal( scope="L" )#
    xRange[1] <- xMinYr#
    xRange[2] <- xMaxYr#
  }#
  #
  yRange <- range( Nrecruits, na.rm=TRUE )#
  if ( fixYaxis )#
  {#
    guiList <- getWinVal( scope="L" )#
    yRange[1] <- yMinNum#
    yRange[2] <- yMaxNum#
  }#
  #
  plot( xRange, yRange, type="n", xlab="", ylab="", yaxt="n" )#
  lines( years, Nrecruits, type="h", lwd=3 )#
  abline( h=poorAvg )#
  abline( h=avgGood,lty=2 )#
  axis( 2, las=2 )#
  box()#
    #
  panLab( 0.05,0.90, adj=0, cex=.VIEWPANCEX, label )#
#   mtext( side=1, line=0.5, outer=T, "Year" )#
  mtext( side=2, line=1., outer=T, las=0, "Number of recruits (millions )" )#
}#
#
#
#Pearsons residuals for HCAM fit to catch-age data, by period#
.plotAgeResids <- function( repObj, label=NULL, annotate=TRUE,#
						fixXaxis=FALSE, fixYaxis=FALSE )#
{#
  years     <- repObj$syr:repObj$nyr#
  yearsP1   <- repObj$residACperiod1[,1]#
  yearsP2   <- repObj$residACperiod2[,1]#
  yearsP3   <- repObj$residACperiod3[,1]#
#
  ages      <- repObj$minAge:repObj$plusGroup#
  residsP1  <- repObj$residACperiod1[,3:10]#
  residsP2  <- repObj$residACperiod2[,3:10]#
  residsP3  <- repObj$residACperiod3[,3:10]#
#
  residsP1  <- t( residsP1 )#
  residsP1  <- as.matrix( residsP1 )#
  residsP2  <- t( residsP2 )#
  residsP2  <- as.matrix( residsP2 )#
  residsP3  <- t( residsP3 )#
  residsP3  <- as.matrix( residsP3 )#
      #
  xRange <- range( years )#
  if ( fixXaxis )#
  {#
    guiList <- getWinVal( scope="L" )#
    xRange[1] <- xMinYr#
    xRange[2] <- xMaxYr#
  }#
#
  yRange <- range( ages )#
  if ( fixYaxis )#
  {#
    guiList <- getWinVal( scope="L" )#
    yRange[1] <- xMinAge#
    yRange[2] <- xMaxAge#
  }#
  #
  par( mfrow=c(3,1) )#
  for ( i in 1:3 )#
  {#
  .plotBubbles( z=residsP1, xval=yearsP1, yval=ages,#
  			   bg.clrs=c("blue","light green","black"), fg.clrs=c("black","black","black"),#
               powr=0.5, size=0.1, xlim=xRange, ylim=yRange, yaxt="n" )#
  axis( 2, las=2 )               #
  legend( "topright",legend="Fishing period 1",bty='n' )#
  mtext( side=2, line=0.5, cex=.VIEWCEX, outer=TRUE, "Age" )#
  panLab( 0.05,0.95, adj=0, cex=.VIEWPANCEX, label )#
#
  .plotBubbles( z=residsP2, xval=yearsP2, yval=ages,#
  			   bg.clrs=c("blue","light green","black"), fg.clrs=c("black","black","black"),  #
               powr=0.5, size=0.1, xlim=xRange, ylim=yRange, yaxt="n" )#
  axis( 2, las=2 )#
  legend( "topright",legend="Fishing period 2",bty='n' )               #
  mtext( side=2, line=0.5, cex=.VIEWCEX, outer=TRUE, "Age" )	#
  panLab( 0.05,0.95, adj=0, cex=.VIEWPANCEX, label )#
               #
  .plotBubbles( z=residsP3, xval=yearsP3, yval=ages,#
  			   bg.clrs=c("blue","light green","black"), fg.clrs=c("black","black","black"),  #
               powr=0.5, size=0.1, xlim=xRange, ylim=yRange, yaxt="n" )#
  axis( 2, las=2 )               #
  legend( "topright",legend="Fishing period 3",bty='n' )  #
  mtext( side=2, line=0.5, cex=.VIEWCEX, outer=TRUE, "Age" )	#
  panLab( 0.05,0.95, adj=0, cex=.VIEWPANCEX, label )#
  #
  }                #
}#
#
#
.plotM <- function( repObj, label=NULL, annotate=TRUE,#
                    fixXaxis=FALSE, fixYaxis=FALSE )#
{#
  years <- c( repObj$syr:repObj$nyr )#
  M     <- c( repObj$M[,1] )#
  #
  xRange <- range( years )#
  if ( fixXaxis )#
  {#
    guiList <- getWinVal( scope="L" )#
    xRange[1] <- xMinYr#
    xRange[2] <- xMaxYr#
  }#
  #
  yRange <- range( M, na.rm=TRUE )#
  if ( fixYaxis )#
  {#
    guiList <- getWinVal( scope="L" )#
    yRange[1] <- yMinM#
    yRange[2] <- yMaxM#
  }#
  #
  plot( xRange, yRange, type="n", axes=FALSE, xlab="", ylab="" )#
  lines( years, M,  col="black", lty=1 )#
#   points( years, M, col="black", pch=16 )#
  #
  axis( side=1 )#
  axis( side=2, las=.VIEWYLAS )#
  box()#
  #
#  tmp$syr:tmp$nyr,tmp$M[,1],type='b',lwd=2,bty='l',yaxs='i',xlab="",#
#    ylab="",lty=1,pch=21,yaxt="n",xaxt="n",ylim=c(0,1.5) )#
#
  panLab( 0.05,0.95, adj=0, cex=.VIEWPANCEX, label )#
#
#   mtext( side=1, line=0.5, cex=.VIEWCEX, outer=TRUE, "Years" )#
  mtext( side=2, line=0.5, cex=.VIEWCEX, outer=TRUE, "Natural mortality (M)" )#
}#
#
#
#instantaneous mortality (M and F)#
.plotMandF <- function( repObj, label=NULL, annotate=TRUE,#
                    fixXaxis=FALSE, fixYaxis=FALSE )#
{#
  years <- c( repObj$syr:repObj$nyr )#
  M     <- c( repObj$M[,1] )#
  F     <- c( repObj$Fyr )#
  #
  xRange <- range( years )#
  if ( fixXaxis )#
  {#
    guiList <- getWinVal( scope="L" )#
    xRange[1] <- xMinYr#
    xRange[2] <- xMaxYr#
  }#
  #
  yRange <- range( M, na.rm=TRUE )#
  if ( fixYaxis )#
  {#
    guiList <- getWinVal( scope="L" )#
    yRange[1] <- yMinM#
    yRange[2] <- yMaxM#
  }#
  #
  plot( xRange, yRange, type="n", axes=FALSE, xlab="", ylab="" )#
  lines( years, M,  col="black", lty=1 )#
  lines( years, F,  col="black", lty=2 )#
  #
  axis( side=1 )#
  axis( side=2, las=.VIEWYLAS )#
  box()#
  #
  if ( annotate )#
  {#
    mfg <- par( "mfg" )#
    if ( mfg[1]==1 && mfg[2]==1 )#
      legend( "topright",legend=c( "M","F" ),#
              bty='n',lty=c(1,2),lwd=c(1,1),ncol=1 )#
  }#
#
  panLab( 0.05,0.95, adj=0, cex=.VIEWPANCEX, label )#
#
#   mtext( side=1, line=0.5, cex=.VIEWCEX, outer=TRUE, "Years" )#
  mtext( side=2, line=0.5, cex=.VIEWCEX, outer=TRUE, "Instantaneous mortality" )#
}#
#
#
.plotMage <- function( repObj, label=NULL, annotate=TRUE,#
                    fixXaxis=FALSE, fixYaxis=FALSE )#
{	#
#
  ages  <- repObj$minAge:repObj$maxAge#
  M     <- repObj$M				# row=years, col=ages 2:10#
  #
  years <- c(repObj$syr:repObj$nyr)#
#
  #
  # Find every tenth year.#
  idxYear <- as.logical( years %% 20 == 0 )#
  #
#   # Now add most recent year.#
  idxYear[ length(idxYear) ] <- TRUE#
#
  xRange <- range( ages )#
  if ( fixXaxis )#
  {#
    guiList <- getWinVal( scope="L" )#
    xRange[1] <- xMinAge#
    xRange[2] <- xMaxAge#
  }#
#
  yRange <- range( repObj$M )	#ages 2:10#
  if ( fixYaxis )#
  {#
    guiList <- getWinVal( scope="L" )#
    yRange[1] <- yMinM#
    yRange[2] <- yMaxM#
  }#
#
  plot( xRange, yRange, type="n", axes=FALSE, xlab="",ylab="" )#
  #
  # Add the points that are not highlighted.#
  tmp <- M[ !idxYear, ]#
  for ( i in 1:nrow(tmp) )#
  {#
    points( jitter( ages ), tmp[i,], pch=21, bg="white", cex=1 )#
  }#
  #
  # Add the points that are to be highlighted.#
  tmp <- M[ idxYear, ]#
  for ( i in 1:nrow(tmp) )#
  {#
    lines( ages, tmp[i,], lty=1 )#
    points( ages, tmp[i,], pch=21, bg=i, cex=1.5 )#
  } #
      #
  axis( side=1 )#
  axis( side=2, las=.VIEWYLAS )#
  box()#
#
  legend( "bottomright", legend=years[idxYear], pch=21, pt.bg=c(1:nrow(tmp)),#
          pt.cex=1.5, lty=1, bty="n" )#
  #
  panLab( 0.05,0.95, adj=0, cex=1.25, label )#
  mtext( side=1, line=0.5, cex=.VIEWCEX, outer=TRUE, "Age" )#
  mtext( side=2, line=0.5, cex=.VIEWCEX, outer=TRUE, "Natural mortality" )#
#
}#
#
#
#Jac plot7- instantanoeus fishing mortality#
.plotF <- function( repObj, label=NULL, annotate=TRUE,#
                    fixXaxis=FALSE, fixYaxis=FALSE )#
{#
  years <- c( repObj$syr:repObj$nyr )#
  F     <- c( repObj$Fyr )#
  #
  xRange <- range( years )#
  if ( fixXaxis )#
  {#
    guiList <- getWinVal( scope="L" )#
    xRange[1] <- xMinYr#
    xRange[2] <- xMaxYr#
  }#
  #
  yRange <- range( F, na.rm=TRUE )#
  if ( fixYaxis )#
  {#
    guiList <- getWinVal( scope="L" )#
    yRange[1] <- yMinF#
    yRange[2] <- yMaxF#
  }#
  #
  plot( xRange, yRange, type="n", axes=FALSE, xlab="", ylab="" )#
  lines( years, F,  col="black", lty=1 )#
#   points( years, F, col="black", pch=16 )#
  #
  axis( side=1 )#
  axis( side=2, las=.VIEWYLAS )#
  box()#
  #
#  tmp$syr:tmp$nyr,tmp$M[,1],type='b',lwd=2,bty='l',yaxs='i',xlab="",#
#    ylab="",lty=1,pch=21,yaxt="n",xaxt="n",ylim=c(0,1.5) )#
#
  panLab( 0.05,0.95, adj=0, cex=.VIEWPANCEX, label )#
#
#   mtext( side=1, line=0.5, cex=.VIEWCEX, outer=TRUE, "Years" )#
  mtext( side=2, line=0.5, cex=.VIEWCEX, outer=TRUE, "Fishing mortality (F)" )#
}#
#
#
#Jac plot1- selectivity #
.plotS <- function( repObj, label=NULL, annotate=TRUE,#
                    fixXaxis=FALSE, fixYaxis=FALSE )#
{#
  years <- c( repObj$syr:repObj$nyr )#
  ages  <- c( repObj$minAge:repObj$maxAge )#
  S     <- repObj$gnSelectivity[,2:10]#
  meanS <- repObj$meanGNselectivity#
  #
  xRange <- range( ages )#
  if ( fixXaxis )#
  {#
    guiList <- getWinVal( scope="L" )#
    xRange[1] <- xMinAge#
    xRange[2] <- xMaxAge#
  }#
  #
  yRange <- range( S, na.rm=TRUE )#
  if ( fixYaxis )#
  {#
    guiList <- getWinVal( scope="L" )#
    yRange[1] <- yMinS#
    yRange[2] <- yMaxS#
  }#
  #
  plot( xRange, yRange, type="n", axes=FALSE, xlab="", ylab="" )#
  for( i in 1:length(S[,1]) )#
  {#
    lines( ages, S[i,],  col="black", lty=2 )#
  }#
  lines( ages, meanS, lwd=3 )#
  points( ages, meanS, pch=16 )#
  #
  axis( side=1 )#
  axis( side=2, las=.VIEWYLAS )#
  box()#
  #
  panLab( 0.05,0.95, adj=0, cex=.VIEWPANCEX, label )#
#
  mtext( side=1, line=0.5, cex=.VIEWCEX, outer=TRUE, "Age" )#
  mtext( side=2, line=0.5, cex=.VIEWCEX, outer=TRUE, "GN selectivity" )#
}#
#
#
#Jac plot10- availability#
.plotA <- function( repObj, label=NULL, annotate=TRUE,#
                    fixXaxis=FALSE, fixYaxis=FALSE )#
{#
  years <- c( repObj$syr:repObj$nyr )#
  ages  <- c( repObj$minAge:repObj$maxAge )#
  A     <- repObj$meanAvailabilityAge#
#
  xRange <- range( ages )#
  if ( fixXaxis )#
  {#
    guiList <- getWinVal( scope="L" )#
    xRange[1] <- xMinAge#
    xRange[2] <- xMaxAge#
  }#
  #
  yRange <- range( A, na.rm=TRUE )#
  if ( fixYaxis )#
  {#
    guiList <- getWinVal( scope="L" )#
    yRange[1] <- yMinS#
    yRange[2] <- yMaxS#
  }#
  #
  plot( xRange, yRange, type="n", axes=FALSE, xlab="", ylab="" )#
  lines( ages, A, col="black", lty=2 )#
  points( ages, A, pch=16 )#
  #
  axis( side=1 )#
  axis( side=2, las=.VIEWYLAS )#
  box()#
  #
  panLab( 0.05,0.95, adj=0, cex=.VIEWPANCEX, label )#
#
  mtext( side=1, line=0.5, cex=.VIEWCEX, outer=TRUE, "Age" )#
  mtext( side=2, line=0.5, cex=.VIEWCEX, outer=TRUE, "Availability" )#
}#
#
#
#Jac plot2- bubble plot#
# Source:     J.Schnute (PBSmodelling)  #
#
# Jac: Why does obsPropAge (in .rep file) include only ages 2:9??#
# ARK: Age 2 is probably the initial age class and 9 is the plus group - but CHECK IT!!! #
#
.plotObsPropAge <- function( repObj, label=NULL, annotate=FALSE,#
                             fixXaxis=FALSE, fixYaxis=FALSE )#
{#
  # ARK: Watch out Jac, the second column contains periods...#
  #      Also, the format for obsPropAge in the rep file is extremely dangerous#
  #      as the year index is attached but NOT the ages.  They are implied by#
  #      the columns.  So, hard to check what plotBubbles is plotting.  I suggest#
  #      that the age proportions be output with fields year, age, propAtAge.#
  #      In your case, period is also output. ARK left it as is.#
  #      In this case, row 1 appears to be age 2, row 8 appear to be age 9.#
  #      The columns are now the years from 1951 on.#
 #
  years      <- repObj$obsPropAge[,1 ]#
  obsPropAge <- repObj$obsPropAge[,c(3:10)]#
  obsPropAge <- t( obsPropAge )#
  obsPropAge <- as.matrix( obsPropAge )#
  #
  xRange <- range( years )#
  if ( fixXaxis )#
  {#
    guiList <- getWinVal( scope="L" )#
    xRange[1] <- xMinYr#
    xRange[2] <- xMaxYr#
  }#
#
  yRange <- range( repObj$obsPropAge )	#JSC: I think this should be ages 2:9#
  if ( fixYaxis )#
  {#
    guiList <- getWinVal( scope="L" )#
    yRange[1] <- xMinAge#
    yRange[2] <- xMaxAge#
  }#
#
  # ARK: Jac, this code modified from PBSmodelling demo PopSim.  It requires that#
  # a vector of recruitments be available.  This would I suppose be the numbers#
  # at age 2 (first age class).  I will use the rep file matrix Nest for now#
  # until you decide what is correct.  I assume Nest is estimated numbers at age#
  # for each cohort 1951:2008+ by year classes 2:10.#
  #
  # JSC: changed this function to use prefishRecAge3, so lines are drawn thru#
  # top 10% of age 3-recruits. (model-predicted recruits)#
  # This variable could be put into the GUI.  For now we set to 10%.#
  percent <- 10#
  tmP <- repObj$prefishRecAge3  # year, numbers, biomass#
  # Fix order of data output#
  x <- tmP[,1]#
  y <- tmP[,2]#
  z <- tmP[,3]#
  o <- order( x )#
  recruits <- cbind( x[o], y[o], z[o] )#
  #
  birthYear <- recruits[,1] - ( repObj$minAge+1 )#
  numAgeClass1 <- recruits[,2]#
#
  if ( percent==0 )#
  {#
    showCohort <- rep( FALSE,length(numAgeClass1) )#
  }#
  else if (percent==100 )#
  {#
    showCohort <- rep( TRUE,length(numAgeClass1) )#
  }#
  else#
  {#
    showCohort <- numAgeClass1 > quantile(numAgeClass1,probs=(100-percent)/100.0)#
  }    #
#
  cohortLine <- function( birthYear,b=1,... )#
  {#
    # X-coordinates.#
    n  <- length(birthYear)#
    x1 <- birthYear#
    x2 <- rep( par()$usr[2],n ) # Maximum x-value replicated n times.#
#
    # Y-coordinates.#
    y1 <- rep( 0,n )#
	  y2 <- y1 + b * (x2-x1)      # Slope-intercept form of a line.#
    y0 <- rep( par()$usr[3],n ) # Maximum y-value replicated n times.#
#
	  for ( i in 1:n )#
	    lines( x=c(x1[i],x1[i],x2[i]),y=c(y0[i],y1[i],y2[i]),... )#
  }#
#
  #logVec <- logVecR[A:(T + A - 1)]          # removes the prehistory#
  #ltyVec <- ifelse(logVecR, 1, 0)#
  #colVec <- ifelse(logVec, colHigh, colLow)#
  #
  .plotBubbles( z=obsPropAge, xval=years, yval=c(2:9),#
                powr=0.5, size=0.1, xlim=xRange, ylim=yRange, yaxt="n" )#
  axis( 2, las=2 )#
  #
  cohortLine( birthYear[showCohort],col="red",lty=1,lwd=2 )#
  #
  if ( annotate ) #
    panLab( 0.03,0.9, adj=0, cex=.VIEWPANCEX, label )#
#
#   mtext( side=1, line=0.5, cex=.VIEWCEX, outer=TRUE, "Year" )#
  mtext( side=2, line=0.5, cex=.VIEWCEX, outer=TRUE, "Age" )#
#
}#
#
.plotBubbles <- function (z, xval = FALSE, yval = FALSE, dnam = FALSE, rpro = FALSE, #
    cpro = FALSE, rres = FALSE, cres = FALSE, powr = 1, size = 0.2, #
    lwd = 2, fg.clrs = c("black", "red", "blue"), bg.clrs = c("white","white","white"), #
    hide0 = FALSE, debug = FALSE, ...) #
{#
    dz <- dim(z)#
    ny <- dz[1]#
    nx <- dz[2]#
    xval1 <- 1:nx#
    yval1 <- 1:ny#
    nx1 <- nx#
    ny1 <- ny#
    if (mode(xval) == "logical") {#
        if (xval[1]) {#
            xval1 <- z[1, ]#
            ny1 <- ny - 1#
        }#
    }#
    if (mode(yval) == "logical") {#
        if (yval[1]) {#
            yval1 <- z[, 1]#
            nx1 <- nx - 1#
        }#
    }#
    xind <- (nx - nx1 + 1):nx#
    x2 <- xval1[xind]#
    yind <- (ny - ny1 + 1):ny#
    y2 <- yval1[yind]#
    if ((mode(xval) == "numeric") & (length(xval) == nx1)) #
        x2 <- xval#
    if ((mode(yval) == "numeric") & (length(yval) == ny1)) #
        y2 <- yval#
    zz <- array(z[yind, xind], dim = c(length(yind), length(xind)), #
        dimnames = dimnames(z))#
    if (dnam & !is.null(dimnames(zz))) {#
        if (!is.null(dimnames(zz)[[2]])) {#
            xnam <- as.numeric(dimnames(zz)[[2]])#
            if (!any(is.na(xnam)) && (length(xnam) == 1 || all(diff(xnam) > #
                0 | all(diff(xnam) < 0)))) #
                x2 <- xnam#
        }#
        if (!is.null(dimnames(zz)[[1]])) {#
            ynam <- as.numeric(dimnames(zz)[[1]])#
            if (!any(is.na(ynam)) && (length(ynam) == 1 || all(diff(ynam) > #
                0 | all(diff(ynam) < 0)))) #
                y2 <- ynam#
        }#
    }#
    xx <- rep(x2, each = length(y2))#
    yy <- rep(y2, length(x2))#
    minz <- min(zz, na.rm = TRUE)#
    maxz <- max(zz, na.rm = TRUE)#
    if (rpro | cpro) {#
        if (minz < 0) {#
            zz <- zz - minz#
            minz <- 0#
            maxz <- max(zz, na.rm = TRUE)#
        }#
    }#
    if (rpro) {#
        zs <- apply(zz, 1, sum, na.rm = TRUE)#
        zz <- sweep(zz, 1, zs, "/")#
    }#
    if (cpro) {#
        zs <- apply(zz, 2, sum, na.rm = TRUE)#
        zz <- sweep(zz, 2, zs, "/")#
    }#
    if (rres) {#
        zm <- apply(zz, 1, mean, na.rm = TRUE)#
        zz <- sweep(zz, 1, zm, "-")#
    }#
    if (cres) {#
        zm <- apply(zz, 2, mean, na.rm = TRUE)#
        zz <- sweep(zz, 2, zm, "-")#
    }#
    zNA <- is.na(zz) | is.nan(zz) | is.infinite(zz)#
    zz[zNA] <- 0#
    z0 <- sign(zz) * abs(zz)^abs(powr)#
    z1 <- z3 <- z0#
    z1[z0 <= 0] <- NA#
    z3[z0 < 0 | z0 > 0] <- NA#
    z2 <- -z0#
    z2[z0 >= 0] <- NA#
    za <- max(z0, na.rm = TRUE)#
    zb <- min(z0, na.rm = TRUE)#
    zM <- max(abs(z0))#
    sz1 <- max(za * size/zM, 0.001)#
    sz2 <- max(-zb * size/zM, 0.001)#
    if (debug) #
        browser()#
    symbols(xx, yy, circles = as.vector(abs(z0)), inches = size, #
        fg = 0, ...)#
    if (debug) #
        browser()#
    if (!hide0 && !all(is.na(z3))) {#
        symbols(xx, yy, circles = as.vector(z3), inches = 0.001, #
            fg = fg.clrs[1], bg = bg.clrs[3], lwd = lwd, add = TRUE, ...)#
    }#
    if (!all(is.na(z2))) {#
        symbols(xx, yy, circles = as.vector(z2), inches = sz2, #
            fg = fg.clrs[1], bg = bg.clrs[2], lwd = lwd, add = TRUE, ...)#
    }#
    if (!all(is.na(z1))) {#
        symbols(xx, yy, circles = as.vector(z1), inches = sz1, #
            fg = fg.clrs[1], bg = bg.clrs[1], lwd = lwd, add = TRUE, ...)#
    }#
    invisible(z0)#
}#
#
#
#------------------------------------------------------------------------------##
# MCMC Plotting Functions                                                      ##
#------------------------------------------------------------------------------##
#
.mcmcDensity <- function( mcmcObj, label=NULL, annotate=TRUE )#
{#
  # Find the active parameters.  If the chain is all equal, then the parameter#
  # was fixed in the model configuration.  This gets a Boolean vector that#
  # indicates which columns have fixed values.#
  #
  iPars <- apply( mcmcObj,2,function(x) { sum(diff(x))!=0.0 } )#
  nPars <- sum( iPars )     # Number of active parameters in mcmc output.#
  #
  tmp <- mcmcObj[ ,iPars ]#
  tmpNames <- names( tmp )#
#
  for ( i in 1:ncol(tmp) )#
  {#
    plot( density( tmp[,i] ), main="", xlab="", ylab="" )#
    abline( v = quantile( tmp[,i],probs = c(0.05,0.95) ), lty=1, lwd=2, col="gray" )#
    abline( v = median(tmp[,i]), lty=2, lwd=3, col=1 )#
    #
    # This is the MPD estimate (max. posterior density)#
    abline( v = tmp[1,i], lwd=2, col="green" )#
    panLab( 0.05,0.95, adj=0, cex=0.9, tmpNames[i] )#
  }#
  if ( !is.null(label) )#
    mtext( side=3, line=-0.5, cex=1.0, outer=T, label )#
}#
#
.mcmcPairs <- function( mcmcObj, label=NULL, annotate=TRUE )#
{#
  panel.mcmc <- function( x,y,z=modes )#
  {#
	xMean <- mean( x,na.rm=T )#
    yMean <- mean( y,na.rm=T )#
		points( x,y,pch=16,cex=0.6,col="darkgray" )#
		abline( h=yMean,v=xMean,col="blue",lty=3 )#
		points( xMean,yMean, bg="cyan", pch=21,cex=1.4 )#
		if ( !is.null(modes) )#
    {#
      # This is logic to figure out what "pair" is being plotted.#
      # The modal estimates are the first row of the mcmcObj.#
      # The par()$mfg calls finds the current row and column indices of#
      # the panel being plotted.#
      #
	xMode <- z[ par()$mfg[2] ]#
    yMode <- z[ par()$mfg[1] ]#
		points( xMode,yMode, bg="red", pch=22, cex=1.4 )#
    }#
  }#
#
  panel.hist <- function( x,... )#
  {#
    # Histograms for diagonal of pairs plot (from PBS Modelling CCA).#
	  usr <- par("usr")#
    on.exit( par(usr) )#
	  h <- hist( x, breaks="Sturges", plot=FALSE )#
	  breaks <- h$breaks#
    nB <- length(breaks)#
	  y <- h$counts#
    y <- y / sum(y)#
	  par( usr = c(usr[1:2], 0, max(y)*1.5) )#
	  rect( breaks[-nB], 0, breaks[-1], y, col="#FFD18F" )#
    box()#
  }#
  #
  # Find the active parameters.  If the chain is all equal, then the parameter#
  # was fixed in the model configuration.  This gets a Boolean vector that#
  # indicates which columns have fixed values.#
  #
  iPars <- apply( mcmcObj,2,function(x) { sum(diff(x))!=0.0 } )#
  nPars <- sum( iPars )     # Number of active parameters in mcmc output.#
  #
  tmp <- mcmcObj[ ,iPars ]#
  tmpNames <- names( tmp )#
  #
  modes <- mcmcObj[1,]#
  pairs( tmp, panel=panel.mcmc, diag.panel=panel.hist, gap=0 )#
  #
  if ( !is.null(label) )#
    mtext( side=3, line=-0.5, cex=1.0, outer=T, label )#
}#
#
.mcmcTraces <- function( mcmcObj, label=NULL, annotate=TRUE )#
{#
  plotTrace <- function( obj )#
  {#
    # Input "obj" is a VECTOR of MCMC samples.#
    # Produces one panel trace plot.#
#
    nSample <- length( obj )#
    plot( c(1:nSample), obj, type="n", axes=FALSE, xlab="", ylab="" )#
    points( c(1:nSample),obj, cex=0.1, pch=16, col="darkgray" )#
#
    lines( lowess( c(1:nSample),obj,f=1/4), lty=1, lwd=1 )#
    abline( h=mean(obj), lty=2 )#
    #
    # Plot MPD point (1st element).#
    points( 1,obj[1], cex=2.0, pch=16, col="green" )#
    points( 1,obj[1], cex=2.0, pch=1 )    #
    #
    axis( side=1 )#
    axis( side=2 )#
    box()#
  }#
#
  # Find the active parameters.  If the chain is all equal, then the parameter#
  # was fixed in the model configuration.  This gets a Boolean vector that#
  # indicates which columns have fixed values.#
  #
  iPars <- apply( mcmcObj,2,function(x) { sum(diff(x))!=0.0 } )#
  nPars <- sum( iPars )     # Number of active parameters in mcmc output.#
  #
  tmp <- mcmcObj[ ,iPars ]#
  tmpNames <- names( tmp )#
  #
  for ( i in 1:ncol(tmp) )#
  {#
    plotTrace( tmp[,i] )#
    panLab( 0.5, 0.9, cex=1.0, tmpNames[i] )  #
  }#
  #
  if ( !is.null(label) )#
    mtext( side=3, line=-0.5, cex=1.0, outer=T, label )#
  mtext( side=1, line=0.5, cex=1.0, outer=T, "Sample" )#
}#
#
#
#------------------------------------------------------------------------------##
# Performance Statistics Functions                                             ##
#------------------------------------------------------------------------------##
#
# .calcAvailHarvestMCMC	(calculates available harvest using MCMC results and herring HCR)#
# Purpose:     Calculated available harvest for major stock areas using herring#
#              harvest control rule with MCMC estimates.#
# Parameters:  None.#
# Returns:     result, a matrix#
# Source:      J.S. Cleary#
calcAvailHarvestMCMC <- function ( hcamHeader )#
{#
  # Create matrix to hold results#
  varNames <- c( "estSByrT","predBavail4","forecastPoor","forecastAvg",#
    	   		"forecastGood","availPoor","availAvg","availGood" )#
  harvest  <- matrix( NA, nrow=nrow(hcamHeader), ncol=length( varNames ) )#
#
  for ( i in 1:nrow(hcamHeader) )#
  {#
    # Here is index for each option in the tracking file.#
    hdr      <- hcamHeader[i,]#
    mcmcName <- gsub( " ", "", hdr$mcmcFile )#
    mcmcObj  <- read.table( file=mcmcName, as.is=TRUE, header=TRUE, sep="\t" )#
  #
    # Remove whitespace from field read from GUI text box.#
    fileName <- gsub( " ", "", hdr$RepFile )#
    repObj   <- lisread( fname=fileName, quiet=TRUE )#
  	cutoff   <- repObj$cutoff			#
    #
    estSByrT       <- median( mcmcObj$estSByrT )#
    predBavailAge4 <- median( mcmcObj$predBavailAge4 )#
    forecastPoor   <- median( mcmcObj$predBavailAge4 ) + median( mcmcObj$forecastRecAge3poor )#
    forecastAvg    <- median( mcmcObj$predBavailAge4 ) + median( mcmcObj$forecastRecAge3avg )#
    forecastGood   <- median( mcmcObj$predBavailAge4 ) + median( mcmcObj$forecastRecAge3good )#
    forecasts      <- c( forecastPoor,forecastAvg,forecastGood )#
 #
    # Populate column 1 with estimated SSB#
    harvest[ i,1 ] <- estSByrT#
    #
    # Populate column 2 with predicted biomass of age 4s#
    harvest[ i,2 ] <- predBavailAge4#
    #
    # Populate columns 3:5 with forecasts under p,a,g recruitment.#
    harvest[ i,3:(length(forecasts)+2) ] <- forecasts#
#
    #JSC (24-Aug-10): this should be changed to include an if stmt for major vs. minor stocks#
	for( j in 1:length(forecasts) )#
    {#
	  # Use herring HCR to calculate available harvest.#
	  harvest[i,(length(forecasts)+2+j)] <- max(min((forecasts[j]-cutoff),(forecasts[j]*0.2)),0)#
    }#
  }#
  #
  # sqlSave requires unique rownames#
  rownames( harvest ) <- paste( hcamHeader$Stock,"-",hcamHeader$Run,sep="" )#
  colnames( harvest ) <- varNames#
  return( harvest )#
}#
#
#
# .calcAvailHarvestMLE	(calculates available harvest using MLE results and herring HCR)#
# Purpose:     Summarizes forecasts and available harvest for major stock areas using herring#
#              harvest control rule with Maximum Likelihood Estimates.#
# Parameters:  None.#
# Returns:     result, a matrix#
# Source:      J.S. Cleary#
calcAvailHarvestMLE <- function ( hcamHeader )#
{#
  # Create matrix to hold results#
  varNames <- c( "estSByrT","predBavail4","mleForecastPoor","mleForecastAvg",#
    	   		"mleForecastGood","mleAvailPoor","mleAvailAvg","mleAvailGood" )#
  harvest  <- matrix( NA, nrow=nrow(hcamHeader), ncol=length( varNames ) )#
#
  for ( i in 1:nrow(hcamHeader) )#
  {#
    hdr      <- hcamHeader[i,]#
    #
    # Remove whitespace from field read from GUI text box.#
    fileName <- gsub( " ", "", hdr$RepFile )#
    repObj   <- lisread( fname=fileName, quiet=TRUE )#
  #
    # MLE results from repObj#
    estSByrT       <- repObj$estSByrT#
    predBavailAge4 <- repObj$prefishBage34yrT[2]	#JSC: check calc!!#
    forecastPoor   <- repObj$prefishForecastBpag[1]#
    forecastAvg    <- repObj$prefishForecastBpag[2]#
    forecastGood   <- repObj$prefishForecastBpag[3]#
    forecasts      <- c( forecastPoor,forecastAvg,forecastGood )	#
      #
    # Populate first 3 columns with forecasts under p,a,g recruitment.#
#     harvest[ i,1 ] <- estSByrT#
#     harvest[ i,2:(length(forecasts)+1) ] <- forecasts#
#     harvest[ i,(length(forecasts)+2):length(varNames) ] <- repObj$availableHarvest#
    #
    harvest[ i,1 ] <- estSByrT#
    harvest[ i,2 ] <- predBavailAge4#
    harvest[ i,3:(length(forecasts)+2) ] <- forecasts#
    harvest[ i,(length(forecasts)+3):length(varNames) ] <- repObj$availableHarvest#
  }#
  #
  # sqlSave requires unique rownames#
  rownames( harvest ) <- paste( hcamHeader$Stock,"-",hcamHeader$Run,sep="" )#
  colnames( harvest ) <- varNames#
  return( harvest )#
}#
#
#------------------------------------------------------------------------------##
#-- GUI Helper Functions (Hidden)                                            --##
#------------------------------------------------------------------------------##
#
# readParFile   (reads an ASCII file with 1 comment line, header, data frame)#
# Purpose:      Reads an ASCII file: 1 comment, 1 header, space-delimited#
#               data frame usually containing columns "parameter" and "value".#
# Parameters:   parFile is a character string indicating the input file.#
# Returns:      result, a data frame.#
# Source:       A.R. Kronlund#
readParFile <- function( parFile="inputFile.par" )#
{#
  # Read the file and store as a dataframe.#
  result <- read.table( file=parFile, as.is=TRUE, header=TRUE, skip=1,#
                        quote="",sep=" " )#
  result#
}#
#
# .getExcelData (Extracts data from viewGuiList)#
# Purpose:    Extracts the simulation parameters from the simGuiPars component#
#             of a saved simulation .Rdata file.  Uses .unEvalList to remove#
#             any list nesting structure.#
# Parameters: hdrObj - the header object from guiView, essentially#
#                      holding the model fitting tracking information.#
# Returns:    result - a data frame where the rows are guiView parameters#
#                      and each simulation is stored in the columns.#
# Source:     A.R. Kronlund#
.getExcelDataFromR <- function( obj )#
{#
  hdr <- obj$hcamHeader#
  for ( i in 1:nrow(hdr) )#
  {#
    # Remove whitespace from field read from GUI text box.#
    fileName <- gsub( " ", "", hdr$RepFile[i] )#
     #
    # Load an Rdata working directory containing a list called blob.#
    cat( "\n(.getExcelDataFromR) Loading",fileName,"...\n" )     #
    load( file=fileName )#
  }#
}#
#
#-----------------------------------------------------------------------------###
#-- Helper Functions (some HIDDEN, e.g., .foo)                              --###
#-----------------------------------------------------------------------------###
#
# .excelTable (Creates and saves a dataframe to Microsoft Excel table)#
# Purpose:    For a given connection and input data, create a dataframe and#
#             save the dataframe as a worksheet in Excel.#
#             If an Excel .xls file with the same name already exists then#
#             delete the file and create a new file, else create a new file.#
# Parameters: channel is a RODBC connection string with the .xls file name#
#             dat       : a list, vector, or matrix containing worksheet data.#
#             tablename : character variable containing the string to appear on#
#                         Excel tabs for each worksheet.#
#             colnam    : a vector of column names with length ncol(dat).#
#             rownam    : a vector of row names with length nrow(dat).#
# Returns:    NULL#
# Source:     Modified from T.K. Deering (PopSim.r).#
.excelTable <- function( channel, dat, tablename, colnam, rownam )#
{#
  dframe             <- as.data.frame( dat )#
  names( dframe )    <- colnam#
  rownames( dframe ) <- rownam#
  sqlSave( channel, dframe, tablename=tablename )#
  #
  return()#
}#
#
#
# .getWinName  (get the current winName)#
# Purpose:     Determine which GUI is active (guiSim, guiView, guiPerf, etc.)#
# Parameters:  None#
# Returns:     A character containing the name of the current GUI window#
# Source:      A.R. Kronlund, modified from PBSref (helper_funs.r)#
.getWinName <- function()#
{#
  win <- .PBSmod$.activeWin#
  #
  # This is only required if PBSask is used, leave it for now.#
  if(win == "PBSask")#
  {#
    win <- getWinVal("win", winName="PBSask")[[1]]   # Hidden field in PBSask#
    win <- gsub("\n", "", win)                       # Remove the linefeed \n#
  }#
  return(win)#
}#
#
# .hcamViewSetup (Setup for hcam creation)#
# Purpose:    Set up and run hcam#
# Parameters: win is a character containing the name of the window to setup#
# Returns:    NULL (invisibly)#
# Source:     PBSref (modified)#
.hcamViewSetup <- function(win)#
{#
  # Get the required libraries.#
  require( PBSmodelling )            # For the GUIs#
  require( RODBC )                   # For the Excel and database SQL#
  gvar <- paste( ".", win, sep="" )  # Global variable name for GUI control file#
  #
  assign( gvar, list(), pos=1 )      # Hidden global list#
  #
  # Copy the GUI window description files and any .exe files to temp directory.#
  dir <- .wkDirSetup()#
  #
  # Close all windows that are currently open to prevent crashes.#
  graphics.off()#
  closeWin()#
  #
  # Can a menu be created?#
  goMenu <- TRUE#
  #
  trckExists <- file.exists( .VIEWTRCK )#
  if ( trckExists )#
  {#
    tmp <- read.table( file=.VIEWTRCK, as.is=TRUE, header=TRUE, sep="," )#
    cat( "MSG (.hCamViewSetup): Viewer tracking file ",.VIEWTRCK, " found.\n" )#
    #
    hcamHeader <- read.table( .VIEWTRCK, as.is=TRUE, header=TRUE, sep="," )#
    #
    # Force the "Select" column to be of type logical.#
    if ( !is.logical( hcamHeader$Select ) )#
    {#
      hcamHeader$Select <- gsub( " ","",hcamHeader$Select )#
      hcamHeader$Select <- as.logical( hcamHeader$Select )#
    }#
    #
    # Save a copy of perfHeader in working directory for GUI creation.                             #
    assign( "hcamHeader", hcamHeader, pos=1 )#
  }#
  else#
  {#
    cat( "ERR (.hCamViewSetup): Viewer tracking file",.VIEWTRCK," does not exist.\n" )#
    goMenu <- FALSE#
  }#
  #
  # Valid conditions exist for menu creation.#
  if ( goMenu )#
  {#
    # Initialize the GUI from the description file using PBSmodelling createWin.#
    createWin( paste( dir, "/", win, "Win.txt", sep="" ) )#
    #
    # Get the GUI parameters and make scope local to this function.#
    guiList <- getWinVal( scope="L", winName=win )#
      #
    # Initialize hcam action.#
    if ( win=="hcamView" )#
    {#
      # Check to see if a previously saved GUI list exists, if so, use it.#
      # One needs to use the new hcamHeader in case somebody changed the order,#
      # or replaced existing rows. But, you need to check to ensure number of#
      # rows did not change. If so, use the new hcamHeader.#
      # Actually, it might be better to check to determine if the new header is#
      # identical to the old header.  all( x==y ).#
      #
      if ( exists( "guiViewList" ) )#
      {#
        if ( !all( guiViewList$hcamHeader==hcamHeader ) )#
        {#
          guiViewList$hcamHeader <- hcamHeader#
        }#
        #
        if ( guiViewList$selectall )#
          guiViewList$hcamHeader$Select <- rep( TRUE,nrow(hcamHeader) )#
     #
        setWinVal( guiViewList )#
        guiList <- guiViewList#
      }#
#
      # Save a copy of the GUI parameters in the working directory.#
      assign( "guiViewList",guiList,pos=1 )#
      #
      # Force plotting action on menu creation with default selection.#
      .doViewPlots() #
    }#
  }#
  else#
    cat( "\nERROR (.hCamViewSetup): GUI creation not possible.\n ")#
#
  return( invisible() )#
}     # .hcamViewSetup#
#
.updateGUI <- function()#
{#
   parentList <- ls( name=parent.frame(n=1) )#
   #
   win     <- .getWinName()                       # Get the current window name#
   guiList <- getWinVal( scope="L", winName=win ) # GUI information local scope#
  #
   # Check for parent environment variables that match the GUI list.#
   isMatch <- is.element( parentList,names(guiList) )#
   parentList <- parentList[isMatch]#
  #
   # Now evaluate the variables into a list.#
   nVals <- length( parentList )#
   vals  <- as.list( 1:nVals )#
   names( vals ) <- parentList#
   #
   for ( i in 1:length(vals) )#
     vals[[i]] <- get( parentList[i], parent.frame(n=1) )#
   #
   setWinVal( vals )  #
}#
#
# .viewFile   (view a file saved in the mseRtemp directory)#
# Purpose:    View a file that is stored in the mseR library directory in the#
#             folder named "mseRtemp". This is the folder where copies of the R#
#             code, the GUI description, the initial database, the ADMB#
#             executable, and the documentation are kept.#
# Parameters: fname is a character containing the name of the file to view #
#             (default is based on the last action performed by the current#
#             GUI window)#
# Returns:    NULL#
# Source:     PBSref (gui_funs.r")#
.viewFile <- function(fname)#
{#
  # These two will be used when mseR is a proper R library.#
  pckg  <- .PACKAGE                    # The name of this package#
  dname <- paste( pckg,.FTEMP,sep="" ) # R directory where the file is located#
  #
  if( missing(fname) )#
  {#
    fname <- getWinAct(.getWinName())[1] # Name of the file to open#
  }#
  #
  # This will be used when mseR is a proper R library.#
	#rdir <- system.file(package = pckg)   # path to the R directory#
	#
	# Reference working directory.#
	wkDir <- getwd()#
  fname <- paste(wkDir, dname, fname, sep = "/")  #
#
  openFile(fname)#
  #
  return()#
}#
#
# .viewHelp   (view a help file or document)#
# Purpose:    View a file that is stored in the mseR library directory in the#
#             folder named "mseRtemp". This is the folder where copies of the R#
#             code, the GUI description, the initial database, the ADMB#
#             executable, and the documentation are kept.#
# Parameters: fname is a character containing the name of the file to view #
#             (default is based on the last action performed by the current#
#             GUI window)#
# Returns:    NULL#
# Source:     PBSref (gui_funs.r")#
.viewHelp <- function(fname)#
{#
  pckg  <- .PACKAGE                      # The name of this package#
  dname <- paste( pckg,.FHELP,sep="" )   # R directory where the file is located#
  #
  if( missing(fname) )#
  {#
    fname <- getWinAct(.getWinName())[1] # Name of the file to open#
  }#
  #
  # This will be used when mseR is a proper R library.#
	#rdir <- system.file(package = pckg)   # path to the R directory#
	#
	# Reference working directory.#
	wkDir <- getwd()                       # Path to R working directory#
  fnam <- paste(wkDir, dname, fname, sep = "/")  #
#
  openFile(fnam)#
  #
  return()#
}#
#
# .wkDirSetup (Working directory set-up):#
# Purpose:    Copy necessary files over to a directory in the current working#
#             directory for easy access. Creates directory if it does not exist.#
# Parameters: None#
# Returns:    The full path to the new directory#
# Source:     PBSref (modified)#
.wkDirSetup <- function()#
{#
  pckg  <- .PACKAGE                       # Current package name.#
  dname <- .FTEMP                         # Directory where files are located#
	#
  fils  <- c(                             # List of files to be copied#
              "hcamViewFuns.r",#
              "hcamViewWin.txt",#
              "hcamAbout.txt"#
             )#
#
  # These two will be used when hCam is a proper R library.#
	#rdir <- system.file(package = pckg)          # Path to the R directory#
  #fnam <- paste(rdir, dname, fils, sep = "/")  # the files you want to copy#
  #
  # Reference working directory.#
  wkDir <- getwd()                       # Path to R working directory#
  fname <- paste( wkDir,fils, sep="/" )  # Files to be copied#
	#
	# Temporary directory for files, create if required.#
  tmpDir <- paste(wkDir, paste(pckg,.FTEMP,sep=""), sep="/")#
  if (!file.exists(tmpDir))#
  {#
    #shell( paste("mkdir", tmpDir) )#
    shell( "mkdir C:/research/herring/hcamTemp", translate=TRUE )#
  }#
  tname <- paste( tmpDir,fils, sep="/" )#
  #
	# Copy those files into this new directory (overwrite any old files)#
  file.copy(fname, tname, overwrite = TRUE)#
  #
  return(wkDir)#
}#
#
#
#------------------------------------------------------------------------------##
#-- GUI Helper Functions (Public)                                            --##
#------------------------------------------------------------------------------##
#
# saveToExcel (Save data in Excel format)#
# Purpose:    Saves data in obj to a Microsoft Excel .xls file.#
# Parameters: fname - a character string file name.#
#             statObj - the result of a call to .calcPerfStats.#
# Returns:    NULL#
# Source:     Modified from saveExcel by T.K. Deering (PopSim.r)#
saveToExcel <- function( fname, statObj )#
{#
	unpackList( statObj,scope="L" )#
	#fname <- promptSaveFile(filetype=list(c(".xls", "Microsoft Excel Spreadsheet")))#
	#
	# No name provided, or "Cancel" selected.#
	if ( fname == "" )#
    return(invisible())#
    #
	# If fname already exists, then remove it.#
	fileGone <- TRUE#
	if ( file.exists(fname) )#
    fileGone <- file.remove( fname )#
    #
  if ( fileGone )#
  {#
  	conn <- RODBC::odbcConnectExcel( fname, readOnly=FALSE )#
	#
  	statObj$trackTable$Select <- as.character(statObj$trackTable$Select)#
	#
	# Save the simulation tracking table.#
	# Note: when writing out to excel, sqlSave has a tendancy to transposes#
	# 	row and column names. In the event of dim Errors, fiddle with t() and [[#]]#
	.excelTable( conn, statObj$trackTable, "Tracking",#
                 dimnames(statObj$trackTable)[[2]],dimnames(statObj$trackTable)[[1]] )#
  #
    # Save the guiView parameters.             #
    .excelTable( conn, t(statObj$guiViewTable), "guiSettings",#
                 dimnames(statObj$guiViewTable)[[1]],dimnames(statObj$guiViewTable)[[2]] )#
   #
	# Save the MLE harvest recommendations.#
    .excelTable( conn, statObj$availHarvestMLE, "availHarvestMLE", #
                 dimnames(statObj$availHarvestMLE)[[2]],dimnames(statObj$availHarvestMLE)[[1]] )#
 #
	# Save the MCMC harvest recommendations.#
    .excelTable( conn, statObj$availHarvestMCMC, "availHarvestMCMC", #
                 dimnames(statObj$availHarvestMCMC)[[2]],dimnames(statObj$availHarvestMCMC)[[1]] )#
                    			#
    odbcClose(conn)#
  }#
  else#
  {#
    cat( "\nERROR (saveToExcel): Results results NOT saved to Excel, permission denied\n" )#
    cat( "\nACTION (saveToExcel): Close or rename file ",fname,"\n " )#
  }#
	return( fileGone )#
}#
#
#-----------------------------------------------------------------------------###
#-- Plotting Functions (some HIDDEN, e.g., .foo)                            --###
#-----------------------------------------------------------------------------###
#
# panLab      (Place text labels in plot region)#
# Purpose:    Place a text label in the plot region defined by (0,1), (0,1).#
#             The ... notation allows all parameters available to "text" to be#
#             passed.#
# Parameters: x, y are the coordinates of the label#
#             txt is the text#
# Returns:    NULL (invisibly)#
# Source:     A.R. Kronlund#
#
panLab <- function( x, y, txt, ... )#
{#
  # Allows text to be placed in plot panel at 0<x<1, 0<y<1.#
  usr <- par( "usr" )#
  par( usr=c(0,1,0,1) )#
  text( x, y, txt, ... )#
  par( usr=usr )#
  return( NULL )#
}#
#
# panLegend   (Place legend in plot region)#
# Purpose:    Place a legend in the plot region defined by (0,1), (0,1).#
#             The ... notation allows all parameters available to "legend" to be#
#             passed.#
# Parameters: x, y are the coordinates of the legend#
#             legTxt is the text associated with the legend#
# Returns:    NULL (invisibly)#
# Source:     A.R. Kronlund#
#
panLegend <- function( x, y, legTxt, ... )#
{#
  # Allows legend to be placed at 0<x<1, 0<y<1.#
  #
  usr <- par( "usr" )#
  par( usr=c(0,1,0,1) )#
  legend( x, y, legend=legTxt, ... )#
  par( usr=usr )#
  return( NULL )#
}
guiView()
?listread
?listread
?lisread
guiView
guiView()
?gsub
setwd('/Users/stevenmartell/Documents/CURRENT PROJECTS/iSCAM')
#-------------------------------------------------------------------------------##
#   iSCAM Viewer: A gui based viewer for iscam inputs and outputs               ##
#                                                                               ##
#                                                                               ##
#   Authors: Steven Martell (with lots of borrowed code from A.R.Kronlund)      ##
#            A.R. Kronlund (Pacific Biological Station, Nanaimo, B.C.)          ##
#   Date: Nov. 22,  2010                                                        ##
#                                                                               ##
#                                                                               ##
#                                                                               ##
#                                                                               ##
#                                                                               ##
# NOTES:                                                                        ##
# 1. requires PBSmodelling                                                      ##
#                                                                               ##
#                                                                               ##
#-------------------------------------------------------------------------------##
#
#
#
#
.iscamViewSetup <- function(win)#
{#
	#Required libraries#
	require(PBSmodelling)#
	#
	#
	#Close any open graphics devices#
	graphics.off()#
	closeWin()#
	#
	#Create new window based on iscamWin.txt#
	createWin("iscamWin.txt")#
}#
#
.iscamViewSetup("test")
setwd('/Users/stevenmartell/Documents/CURRENT PROJECTS/iSCAM')
#-------------------------------------------------------------------------------##
#   iSCAM Viewer: A gui based viewer for iscam inputs and outputs               ##
#                                                                               ##
#                                                                               ##
#   Authors: Steven Martell (with lots of borrowed code from A.R.Kronlund)      ##
#            A.R. Kronlund (Pacific Biological Station, Nanaimo, B.C.)          ##
#   Date: Nov. 22,  2010                                                        ##
#                                                                               ##
#                                                                               ##
#                                                                               ##
#                                                                               ##
#                                                                               ##
# NOTES:                                                                        ##
# 1. requires PBSmodelling                                                      ##
#                                                                               ##
#                                                                               ##
#-------------------------------------------------------------------------------##
#
#
#
#
.iscamViewSetup <- function(win)#
{#
	#Required libraries#
	require(PBSmodelling)#
	#
	#
	#Close any open graphics devices#
	graphics.off()#
	closeWin()#
	#
	#Create new window based on iscamWin.txt#
	createWin("iscamWin.txt")#
}#
#
.iscamViewSetup("test")
setwd('/Users/stevenmartell/Documents/CURRENT PROJECTS/iSCAM')
#-------------------------------------------------------------------------------##
#   iSCAM Viewer: A gui based viewer for iscam inputs and outputs               ##
#                                                                               ##
#                                                                               ##
#   Authors: Steven Martell (with lots of borrowed code from A.R.Kronlund)      ##
#            A.R. Kronlund (Pacific Biological Station, Nanaimo, B.C.)          ##
#   Date: Nov. 22,  2010                                                        ##
#                                                                               ##
#                                                                               ##
#                                                                               ##
#                                                                               ##
#                                                                               ##
# NOTES:                                                                        ##
# 1. requires PBSmodelling                                                      ##
#                                                                               ##
#                                                                               ##
#-------------------------------------------------------------------------------##
#
#
#
#
.iscamViewSetup <- function(win)#
{#
	#Required libraries#
	require(PBSmodelling)#
	#
	#
	#Close any open graphics devices#
	graphics.off()#
	closeWin()#
	#
	#Create new window based on iscamWin.txt#
	createWin("iscamWin.txt")#
}#
#
.iscamViewSetup("test")
?notebook
??notebook
?ttknotebook
?ttknotebook
setwd('/Users/stevenmartell/Documents/CURRENT PROJECTS/iSCAM')
#-------------------------------------------------------------------------------##
#   iSCAM Viewer: A gui based viewer for iscam inputs and outputs               ##
#                                                                               ##
#                                                                               ##
#   Authors: Steven Martell (with lots of borrowed code from A.R.Kronlund)      ##
#            A.R. Kronlund (Pacific Biological Station, Nanaimo, B.C.)          ##
#   Date: Nov. 22,  2010                                                        ##
#                                                                               ##
#                                                                               ##
#                                                                               ##
#                                                                               ##
#                                                                               ##
# NOTES:                                                                        ##
# 1. requires PBSmodelling                                                      ##
#                                                                               ##
#                                                                               ##
#-------------------------------------------------------------------------------##
#
#
#
#
.iscamViewSetup <- function(win)#
{#
	#Required libraries#
	require(PBSmodelling)#
	#
	#
	#Close any open graphics devices#
	graphics.off()#
	closeWin()#
	#
	#Create new window based on iscamWin.txt#
	createWin("iscamWin.txt")#
}#
#
.iscamViewSetup("test")
setwd('/Users/stevenmartell/Documents/CURRENT PROJECTS/iSCAM')
#-------------------------------------------------------------------------------##
#   iSCAM Viewer: A gui based viewer for iscam inputs and outputs               ##
#                                                                               ##
#                                                                               ##
#   Authors: Steven Martell (with lots of borrowed code from A.R.Kronlund)      ##
#            A.R. Kronlund (Pacific Biological Station, Nanaimo, B.C.)          ##
#   Date: Nov. 22,  2010                                                        ##
#                                                                               ##
#                                                                               ##
#                                                                               ##
#                                                                               ##
#                                                                               ##
# NOTES:                                                                        ##
# 1. requires PBSmodelling                                                      ##
#                                                                               ##
#                                                                               ##
#-------------------------------------------------------------------------------##
#
#
#
#
.iscamViewSetup <- function(win)#
{#
	#Required libraries#
	require(PBSmodelling)#
	#
	#
	#Close any open graphics devices#
	graphics.off()#
	closeWin()#
	#
	#Create new window based on iscamWin.txt#
	createWin("iscamWin.txt")#
}#
#
.iscamViewSetup("test")
setwd('/Users/stevenmartell/Documents/CURRENT PROJECTS/iSCAM')
#-------------------------------------------------------------------------------##
#   iSCAM Viewer: A gui based viewer for iscam inputs and outputs               ##
#                                                                               ##
#                                                                               ##
#   Authors: Steven Martell (with lots of borrowed code from A.R.Kronlund)      ##
#            A.R. Kronlund (Pacific Biological Station, Nanaimo, B.C.)          ##
#   Date: Nov. 22,  2010                                                        ##
#                                                                               ##
#                                                                               ##
#                                                                               ##
#                                                                               ##
#                                                                               ##
# NOTES:                                                                        ##
# 1. requires PBSmodelling                                                      ##
#                                                                               ##
#                                                                               ##
#-------------------------------------------------------------------------------##
#
#
#
#
.iscamViewSetup <- function(win)#
{#
	#Required libraries#
	require(PBSmodelling)#
	#
	#
	#Close any open graphics devices#
	graphics.off()#
	closeWin()#
	#
	#Create new window based on iscamWin.txt#
	createWin("iscamWin.txt")#
}#
#
.iscamViewSetup("test")
setwd('/Users/stevenmartell/Documents/CURRENT PROJECTS/iSCAM')
#-------------------------------------------------------------------------------##
#   iSCAM Viewer: A gui based viewer for iscam inputs and outputs               ##
#                                                                               ##
#                                                                               ##
#   Authors: Steven Martell (with lots of borrowed code from A.R.Kronlund)      ##
#            A.R. Kronlund (Pacific Biological Station, Nanaimo, B.C.)          ##
#   Date: Nov. 22,  2010                                                        ##
#                                                                               ##
#                                                                               ##
#                                                                               ##
#                                                                               ##
#                                                                               ##
# NOTES:                                                                        ##
# 1. requires PBSmodelling                                                      ##
#                                                                               ##
#                                                                               ##
#-------------------------------------------------------------------------------##
#
#
#
#
.iscamViewSetup <- function(win)#
{#
	#Required libraries#
	require(PBSmodelling)#
	#
	#
	#Close any open graphics devices#
	graphics.off()#
	closeWin()#
	#
	#Create new window based on iscamWin.txt#
	createWin("iscamWin.txt")#
}#
#
.iscamViewSetup("test")
